<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Welcome to Firebase Hosting</title>

    <!-- update the version number as needed -->
    <script defer src="/__/firebase/12.4.0/firebase-app-compat.js"></script>
    <!-- include only the Firebase features as you need -->
    <script defer src="/__/firebase/12.4.0/firebase-auth-compat.js"></script>
    <script defer src="/__/firebase/12.4.0/firebase-database-compat.js"></script>
    <script defer src="/__/firebase/12.4.0/firebase-firestore-compat.js"></script>
    <script defer src="/__/firebase/12.4.0/firebase-functions-compat.js"></script>
    <script defer src="/__/firebase/12.4.0/firebase-messaging-compat.js"></script>
    <script defer src="/__/firebase/12.4.0/firebase-storage-compat.js"></script>
    <script defer src="/__/firebase/12.4.0/firebase-analytics-compat.js"></script>
    <script defer src="/__/firebase/12.4.0/firebase-remote-config-compat.js"></script>
    <script defer src="/__/firebase/12.4.0/firebase-performance-compat.js"></script>
    <!-- 
      initialize the SDK after all desired features are loaded, set useEmulator to false
      to avoid connecting the SDK to running emulators.
    -->
    <script defer src="/__/firebase/init.js?useEmulator=true"></script>

    <style media="screen">
      :root {
        --bg-start: #e3f2fd;
        --bg-end: #f3e5f5;
        --text: rgba(0,0,0,0.87);
        --panel-bg: #ffffff;
        --panel-border: rgba(0,0,0,.06);
        --btn-start: #1e88e5;
        --btn-end: #3949ab;
        --accent: #1a237e;
        --subtle: rgba(0,0,0,.65);
        --pointer: #e53935;
        --win: #2e7d32;
        --lose: #c62828;
        --wheel-border: #263238;
      }
      body.dark {
        --bg-start: #000000;
        --bg-end: #0a0a0a;
        --text: rgba(255,255,255,0.98);
        --panel-bg: #050505;
        --panel-border: rgba(255,255,255,.2);
        --btn-start: #818cf8;
        --btn-end: #4f46e5;
        --accent: #c7d2fe;
        --subtle: rgba(255,255,255,.85);
        --pointer: #fca5a5;
        --win: #6ee7b7;
        --lose: #fca5a5;
        --wheel-border: #000000;
      }
      body { background: linear-gradient(135deg, var(--bg-start), var(--bg-end)); color: var(--text); font-family: Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
      #message { display: none; }
      #message h2 { color: #ffa100; font-weight: bold; font-size: 16px; margin: 0 0 8px; }
      #message h1 { font-size: 22px; font-weight: 300; color: rgba(0,0,0,0.6); margin: 0 0 16px;}
      #message p { line-height: 140%; margin: 16px 0 24px; font-size: 14px; }
      #message a { display: block; text-align: center; background: #039be5; text-transform: uppercase; text-decoration: none; color: white; padding: 16px; border-radius: 4px; }
      #message, #message a { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); }
      #load { color: rgba(0,0,0,0.4); text-align: center; font-size: 13px; }
      @media (max-width: 600px) {
        body, #message { margin-top: 0; background: linear-gradient(135deg, var(--bg-start), var(--bg-end)); box-shadow: none; }
        body { border-top: 16px solid #ffa100; }
      }
      /* Roulette styles */
      .page { max-width: 1000px; margin: 32px auto; padding: 0 16px; }
      .title { text-align: center; color: var(--accent); margin: 8px 0 16px; font-weight: 700; }
      .subtitle { text-align: center; color: var(--subtle); margin-bottom: 16px; }
      #roulette-app { max-width: 960px; margin: 24px auto; display: flex; gap: 24px; align-items: center; justify-content: center; }
      #wheel-wrapper { position: relative; width: 320px; height: 320px; }
      #wheel { width: 100%; height: 100%; display: block; border-radius: 50%; box-shadow: 0 12px 32px rgba(0,0,0,0.18); border: 10px solid var(--wheel-border); background: radial-gradient(circle at 50% 50%, rgba(255,255,255,.1), rgba(0,0,0,.1)); }
      #pointer { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 12px solid transparent; border-right: 12px solid transparent; border-top: 18px solid var(--pointer); z-index: 2; }
      #side-panel { min-width: 240px; background: var(--panel-bg); border-radius: 12px; padding: 16px; box-shadow: 0 6px 20px rgba(0,0,0,0.12); display: flex; flex-direction: column; gap: 12px; border: 1px solid var(--panel-border); }
      .metric { display: flex; align-items: center; justify-content: space-between; font-size: 14px; }
      .metric .value { font-weight: bold; }
      .metric input[type="number"] { width: 90px; padding: 6px 8px; border-radius: 8px; border: 1px solid var(--panel-border); background: transparent; color: var(--text); }
      #spin-btn { align-self: flex-end; background: linear-gradient(135deg, var(--btn-start), var(--btn-end)); color: #fff; border: none; padding: 12px 18px; border-radius: 8px; cursor: pointer; text-transform: uppercase; letter-spacing: .5px; box-shadow: 0 4px 10px rgba(0,0,0,.15); }
      #spin-btn:disabled { opacity: .6; cursor: not-allowed; }
      #skip-btn { align-self: flex-end; background: #607d8b; color: #fff; border: none; padding: 12px 18px; border-radius: 8px; cursor: pointer; text-transform: uppercase; letter-spacing: .5px; box-shadow: 0 4px 10px rgba(0,0,0,.15); margin-left: 8px; }
      #skip-btn:disabled { opacity: .6; cursor: not-allowed; }
      #result { font-size: 13px; color: var(--subtle); min-height: 18px; }
      .legend { font-size: 12px; color: var(--subtle); }
      /* Header */
      .app-header { position: sticky; top: 0; z-index: 10; display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; backdrop-filter: blur(6px); background: linear-gradient(135deg, var(--bg-start), var(--bg-end)); border-bottom: 1px solid var(--panel-border); }
      .brand { font-weight: 700; color: var(--accent); }
      .toggle { display: flex; align-items: center; gap: 8px; }
      .switch { position: relative; width: 46px; height: 26px; }
      .switch input { opacity: 0; width: 0; height: 0; }
      .slider { position: absolute; cursor: pointer; inset: 0; background: #cfd8dc; transition: .2s; border-radius: 999px; }
      .slider:before { content: ""; position: absolute; height: 20px; width: 20px; left: 3px; top: 3px; background: #fff; transition: .2s; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,.3); }
      input:checked + .slider { background: #37474f; }
      input:checked + .slider:before { transform: translateX(20px); }
      /* Home grid */
      #home { max-width: 1100px; margin: 24px auto; padding: 0 16px; display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; }
      .card { background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 12px; padding: 16px; box-shadow: 0 6px 20px rgba(0,0,0,0.08); display: flex; flex-direction: column; gap: 8px; }
      .card h3 { margin: 0; }
      .card p { margin: 0; color: var(--subtle); font-size: 14px; }
      .card button { align-self: flex-start; background: linear-gradient(135deg, var(--btn-start), var(--btn-end)); color: #fff; border: none; padding: 10px 14px; border-radius: 8px; cursor: pointer; }
      /* Poker (Texas Hold'em) styles */
      #poker-app { max-width: 1100px; margin: 24px auto; padding: 0 16px; display: none; }
      .poker-table { background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 16px; padding: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.12); display: grid; grid-template-rows: auto auto auto; gap: 12px; }
      .seats { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; align-items: start; }
      .seat { background: rgba(0,0,0,.03); border: 1px dashed var(--panel-border); border-radius: 12px; padding: 8px; display: flex; flex-direction: column; gap: 6px; position: relative; }
      .seat.me { background: rgba(25,118,210,.08); }
      body.dark .seat { background: rgba(255,255,255,.12); }
      body.dark .seat.me { background: rgba(129,140,248,.25); }
      .seat-header { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--subtle); }
      .stack { font-weight: 700; }
      .dealer { font-size: 10px; background: var(--accent); color: #fff; padding: 2px 6px; border-radius: 999px; }
      .hole { display: flex; gap: 6px; }
      .community { display: flex; justify-content: center; gap: 8px; padding: 8px 0; }
      .pot { text-align: center; font-weight: 700; }
      .controls { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; }
      .actions { background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 12px; padding: 12px; display: flex; flex-direction: column; gap: 10px; }
      .action-row { display: flex; gap: 8px; flex-wrap: wrap; }
      .bet-input { display: flex; gap: 8px; align-items: center; }
      .bet-input input { width: 120px; padding: 8px; border-radius: 8px; border: 1px solid var(--panel-border); background: transparent; color: var(--text); }
      .log { background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 12px; padding: 12px; max-height: 160px; overflow: auto; font-size: 12px; color: var(--subtle); }
      .hidden-card { background: linear-gradient(135deg, var(--btn-start), var(--btn-end)); color: transparent; position: relative; overflow: hidden; width: 48px; height: 64px; border-radius: 8px; border: 1px solid var(--panel-border); }
      .hidden-card:after { content: ""; position: absolute; inset: 0; background: repeating-linear-gradient(45deg, rgba(255,255,255,.25) 0 8px, rgba(255,255,255,.15) 8px 16px); }
      .card-ui { width: 48px; height: 64px; background: #fff; border-radius: 8px; border: 1px solid #e0e0e0; display: flex; flex-direction: column; justify-content: space-between; padding: 6px; box-shadow: 0 4px 10px rgba(0,0,0,.06); }
      .card-ui.red { color: #d32f2f; }
      .card-ui.black { color: #263238; }
      .card-top, .card-bottom { font-weight: 700; font-size: 12px; }
      .card-center { text-align: center; font-size: 14px; }
      .btn { background: linear-gradient(135deg, var(--btn-start), var(--btn-end)); color: #fff; border: none; padding: 10px 14px; border-radius: 8px; cursor: pointer; }
      .btn.secondary { background: transparent; color: var(--text); border: 1px solid var(--panel-border); }
      .btn:disabled { opacity: .6; cursor: not-allowed; }
      @media (max-width: 900px) { .controls { grid-template-columns: 1fr; } .seats { grid-template-columns: repeat(2, 1fr); } }
      @media (max-width: 700px) {
        #roulette-app { flex-direction: column; }
        #side-panel { width: 100%; }
      }
      /* Blackjack styles */
      #blackjack-app { max-width: 960px; margin: 24px auto; display: none; gap: 24px; align-items: flex-start; justify-content: center; }
      .bj-table { background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 12px; padding: 16px; box-shadow: 0 6px 20px rgba(0,0,0,0.12); width: 100%; max-width: 820px; }
      .bj-row { display: flex; align-items: center; justify-content: space-between; gap: 16px; margin-bottom: 12px; }
      .bj-label { font-weight: 700; color: var(--accent); }
      .bj-total { font-weight: 700; }
      .bj-hand { display: flex; gap: 8px; flex-wrap: wrap; }
      .bj-card { width: 52px; height: 74px; border-radius: 8px; border: 1px solid var(--panel-border); background: #fff; display: flex; align-items: center; justify-content: center; font-weight: 700; box-shadow: 0 2px 8px rgba(0,0,0,.08); }
      .bj-card.black { color: #111; }
      .bj-card.red { color: #c62828; }
      .bj-card.back { background: repeating-linear-gradient(45deg, #263238 0, #263238 6px, #37474f 6px, #37474f 12px); color: transparent; border-color: #1b2830; }
      .bj-controls { display: flex; gap: 10px; margin-top: 8px; }
      .bj-controls button { background: linear-gradient(135deg, var(--btn-start), var(--btn-end)); color: #fff; border: none; padding: 10px 14px; border-radius: 8px; cursor: pointer; }
      .bj-status { min-height: 20px; color: var(--subtle); margin-top: 8px; }
    </style>
  </head>
  <body>
    <a href="#blackjack-app" style="position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;" onfocus="this.style.cssText='position:static;padding:8px;display:inline-block;background:#ffd54f;color:#000;border-radius:6px;margin:8px'" onblur="this.style.cssText='position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;'">Skip to Blackjack</a>
    <div class="app-header">
      <div class="brand">Gambling Simulator</div>
      <div style="display: flex; align-items: center; gap: 16px;">
        <a href="index.html" style="background: transparent; border: 1px solid var(--panel-border); color: var(--text); padding: 8px 16px; border-radius: 8px; text-decoration: none; font-size: 14px; transition: all 0.2s;">Back to Home</a>
        <div class="toggle">
          <span style="font-size:14px;color:var(--subtle)">Dark Mode</span>
          <label class="switch">
            <input id="theme-toggle" type="checkbox" aria-label="Toggle dark mode">
            <span class="slider"></span>
          </label>
        </div>
      </div>
    </div>
    <div id="message">
      <p id="load" style="display:none"></p>
      
    </div>
    
    <div class="page" id="home-header">
      <h1 class="title">Welcome</h1>
      <div class="subtitle">Choose an app to launch</div>
    </div>
    <section id="home">
      <div class="card">
        <h3>Roulette</h3>
        <p>Spin the wheel and try your luck.</p>
        <button id="open-roulette">Open</button>
      </div>
      <div class="card">
        <h3>Blackjack</h3>
        <p>Beat the dealer without going over 21.</p>
        <button id="open-blackjack">Open</button>
      </div>
      <div class="card">
        <h3>Poker</h3>
        <p>Texas Hold'em vs 4 CPUs. $3/$5 blinds.</p>
        <button id="open-poker">Open</button>
      </div>
      <div class="card">
        <h3>Coming Soon</h3>
        <p>More mini-apps will appear here.</p>
        <button disabled>Not available</button>
      </div>
    </section>

    <div class="page" id="blackjack-header" style="display:none">
      <h1 class="title">Blackjack</h1>
      <div class="subtitle">Beat the dealer without going over 21.</div>
    </div>
    <div id="blackjack-app" role="region" aria-labelledby="blackjack-title">
      <div class="bj-table" role="group" aria-label="Blackjack table">
        <div class="bj-row">
          <div class="bj-label" id="bj-dealer-label">Dealer</div>
          <div class="bj-total" id="bj-dealer-total" aria-live="polite">â€”</div>
        </div>
        <div class="bj-hand" id="bj-dealer-hand" role="list" aria-labelledby="bj-dealer-label"></div>
        <hr style="border: none; border-top: 1px solid var(--panel-border); margin: 16px 0;">
        <div class="bj-row">
          <div class="bj-label" id="bj-player-label">You</div>
          <div class="bj-total" id="bj-player-total" aria-live="polite">â€”</div>
        </div>
        <div class="bj-hand" id="bj-player-hand" role="list" aria-labelledby="bj-player-label"></div>
        <div class="bj-row" id="bj-player-row-2" style="display:none">
          <div class="bj-label" id="bj-player-label-2">You - Hand 2</div>
          <div class="bj-total" id="bj-player-total-2" aria-live="polite">â€”</div>
        </div>
        <div class="bj-hand" id="bj-player-hand-2" role="list" aria-labelledby="bj-player-label-2" style="display:none"></div>
        <div class="bj-row" id="bj-player-row-3" style="display:none">
          <div class="bj-label" id="bj-player-label-3">You - Hand 3</div>
          <div class="bj-total" id="bj-player-total-3" aria-live="polite">â€”</div>
        </div>
        <div class="bj-hand" id="bj-player-hand-3" role="list" aria-labelledby="bj-player-label-3" style="display:none"></div>
        <div class="bj-row" id="bj-player-row-4" style="display:none">
          <div class="bj-label" id="bj-player-label-4">You - Hand 4</div>
          <div class="bj-total" id="bj-player-total-4" aria-live="polite">â€”</div>
        </div>
        <div class="bj-hand" id="bj-player-hand-4" role="list" aria-labelledby="bj-player-label-4" style="display:none"></div>
        <div class="bj-controls" role="group" aria-label="Blackjack controls">
          <button id="bj-deal" aria-keyshortcuts="D">Deal</button>
          <button id="bj-hit" disabled aria-keyshortcuts="H">Hit</button>
          <button id="bj-stand" disabled aria-keyshortcuts="S">Stand</button>
          <button id="bj-split" disabled aria-keyshortcuts="P" aria-label="Split hand">Split</button>
          <button id="bj-new" disabled aria-keyshortcuts="N">New Round</button>
          <button id="bj-home" style="background:transparent;border:1px solid var(--panel-border);color:var(--text);">Home</button>
        </div>
        <div class="metric"><span>Bankroll</span><span id="bj-bankroll" class="value">$100.00</span></div>
        <div class="metric" style="gap:12px; align-items:center;">
          <span>Bet / Round</span>
          <span class="value" style="display:flex;align-items:center;gap:8px;">
            $<input id="bj-bet" type="number" min="1" step="1" value="10" style="width:72px;padding:6px 8px;border:1px solid var(--panel-border);border-radius:6px;background:transparent;color:var(--text)">
          </span>
        </div>
        <div class="bj-status" id="bj-status" role="status" aria-live="polite"></div>
      </div>
    </div>

    <div class="page" id="roulette-header" style="display:none">
      <h1 class="title">Roulette</h1>
      <div class="subtitle">Spin the wheel and try your luck.</div>
    </div>
    <div id="roulette-app" style="display:none">
      <div id="wheel-wrapper">
        <canvas id="wheel" width="320" height="320"></canvas>
        <div id="pointer"></div>
      </div>
      <div id="side-panel">
        <div class="metric"><span>Bet Amount</span><span class="value"><input id="bet-input" type="number" min="1" step="1" value="5"></span></div>
        <div class="metric"><span>Bankroll</span><span id="profit" class="value">$0</span></div>
        <div id="result"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end;">
          <button id="spin-btn">Spin</button>
          <button id="skip-btn" disabled>Skip</button>
        </div>
        <button id="go-home" style="margin-top:8px;background:transparent;border:1px solid var(--panel-border);color:var(--text);padding:10px 14px;border-radius:8px;cursor:pointer;">Home</button>
        <div class="legend">Pointer indicates the winning segment at the top.</div>
      </div>
    </div>

    <div class="page" id="poker-header" style="display:none">
      <h1 class="title">Texas Hold'em</h1>
      <div class="subtitle">Play vs 4 computers. Blinds: $3 / $5. No-limit betting.</div>
    </div>
    <section id="poker-app" style="display:none">
      <div class="poker-table">
        <div class="seats" id="poker-seats"></div>
        <div class="community" id="poker-community"></div>
        <div class="pot" id="poker-pot">Pot: $0.00</div>
      </div>
      <div class="controls">
        <div class="actions">
          <div class="metric"><span>Bankroll</span><span id="poker-bankroll" class="value">$100.00</span></div>
          <div class="metric"><span>To Call</span><span id="to-call" class="value">$0.00</span></div>
          <div class="action-row">
            <button id="btn-fold" class="btn secondary" disabled>Fold</button>
            <button id="btn-checkcall" class="btn" disabled>Check</button>
            <button id="btn-raise" class="btn" disabled>Raise</button>
          </div>
          <div class="bet-input">
            <label for="raise-amount" style="font-size:12px;color:var(--subtle)">Raise to</label>
            <input id="raise-amount" type="number" min="0" step="1" value="10" />
            <button id="btn-allin" class="btn" disabled>All-in</button>
          </div>
          <div id="poker-status" class="legend"></div>
        </div>
        <div class="log" id="poker-log"></div>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px;">
        <button id="btn-newhand" class="btn">New Hand</button>
        <button id="go-home-poker" class="btn secondary">Home</button>
      </div>
    </section>


    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const loadEl = document.querySelector('#load');
        // // ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥
        // // The Firebase SDK is initialized and available here!
        //
        // firebase.auth().onAuthStateChanged(user => { });
        // firebase.database().ref('/path/to/ref').on('value', snapshot => { });
        // firebase.firestore().doc('/foo/bar').get().then(() => { });
        // firebase.functions().httpsCallable('yourFunction')().then(() => { });
        // firebase.messaging().requestPermission().then(() => { });
        // firebase.storage().ref('/path/to/ref').getDownloadURL().then(() => { });
        // firebase.analytics(); // call to activate
        // firebase.analytics().logEvent('tutorial_completed');
        // firebase.performance(); // call to activate
        //
        // // ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥

        try {
          if (loadEl) {
            let app = firebase.app();
            let features = [
              'auth', 
              'database', 
              'firestore',
              'functions',
              'messaging', 
              'storage', 
              'analytics', 
              'remoteConfig',
              'performance',
            ].filter(feature => typeof app[feature] === 'function');
            loadEl.textContent = `Firebase SDK loaded with ${features.join(', ')}`;
          }
        } catch (e) {
          console.error(e);
          if (loadEl) loadEl.textContent = 'Error loading the Firebase SDK, check the console.';
        }

        // Roulette implementation
        const canvas = document.getElementById('wheel');
        const ctx = canvas.getContext('2d');
        const spinButton = document.getElementById('spin-btn');
        const skipButton = document.getElementById('skip-btn');
        const profitEl = document.getElementById('profit');
        const resultEl = document.getElementById('result');
        const wheelWrapper = document.getElementById('wheel-wrapper');
        const betInput = document.getElementById('bet-input');
        const themeToggle = document.getElementById('theme-toggle');
        const homeSection = document.getElementById('home');
        const homeHeader = document.getElementById('home-header');
        const openRouletteBtn = document.getElementById('open-roulette');
        const rouletteHeader = document.getElementById('roulette-header');
        const goHomeBtn = document.getElementById('go-home');
        // Poker refs
        const openPokerBtn = document.getElementById('open-poker');
        const pokerHeader = document.getElementById('poker-header');
        const pokerApp = document.getElementById('poker-app');
        const pokerSeatsEl = document.getElementById('poker-seats');
        const pokerCommunityEl = document.getElementById('poker-community');
        const pokerPotEl = document.getElementById('poker-pot');
        const pokerBankrollEl = document.getElementById('poker-bankroll');
        const toCallEl = document.getElementById('to-call');
        const pokerStatusEl = document.getElementById('poker-status');
        const pokerLogEl = document.getElementById('poker-log');
        const btnFold = document.getElementById('btn-fold');
        const btnCheckCall = document.getElementById('btn-checkcall');
        const btnRaise = document.getElementById('btn-raise');
        const btnAllIn = document.getElementById('btn-allin');
        const inputRaise = document.getElementById('raise-amount');
        const btnNewHand = document.getElementById('btn-newhand');
        const goHomePokerBtn = document.getElementById('go-home-poker');
        // Blackjack refs
        const openBlackjackBtn = document.getElementById('open-blackjack');
        const blackjackHeader = document.getElementById('blackjack-header');
        const blackjackApp = document.getElementById('blackjack-app');
        const bjDealerHandEl = document.getElementById('bj-dealer-hand');
        const bjPlayerHandEl = document.getElementById('bj-player-hand');
        const bjPlayerHandEl2 = document.getElementById('bj-player-hand-2');
        const bjDealerTotalEl = document.getElementById('bj-dealer-total');
        const bjPlayerTotalEl = document.getElementById('bj-player-total');
        const bjPlayerTotalEl2 = document.getElementById('bj-player-total-2');
        const bjPlayerHandEl3 = document.getElementById('bj-player-hand-3');
        const bjPlayerHandEl4 = document.getElementById('bj-player-hand-4');
        const bjPlayerTotalEl3 = document.getElementById('bj-player-total-3');
        const bjPlayerTotalEl4 = document.getElementById('bj-player-total-4');
        const bjStatusEl = document.getElementById('bj-status');
        const bjBankrollEl = document.getElementById('bj-bankroll');
        const bjBetInput = document.getElementById('bj-bet');
        function getBjBet() {
          const v = Math.max(1, Math.floor(Number(bjBetInput?.value || 10)));
          if (bjBetInput) bjBetInput.value = String(v);
          return v;
        }
        const bjDealBtn = document.getElementById('bj-deal');
        const bjHitBtn = document.getElementById('bj-hit');
        const bjStandBtn = document.getElementById('bj-stand');
        const bjSplitBtn = document.getElementById('bj-split');
        const bjNewBtn = document.getElementById('bj-new');
        const bjHomeBtn = document.getElementById('bj-home');

        // Shared bankroll across all games
        let bankroll = parseFloat(localStorage.getItem('bankroll') || '100');
        function persistBankroll() {
          localStorage.setItem('bankroll', String(bankroll));
        }
        function updateSharedBankrollUI() {
          if (profitEl) {
            profitEl.textContent = formatMoney(bankroll);
            profitEl.style.color = bankroll >= 0 ? 'var(--win)' : 'var(--lose)';
          }
          if (pokerBankrollEl) {
            pokerBankrollEl.textContent = formatMoney(bankroll);
            pokerBankrollEl.style.color = bankroll >= 0 ? 'var(--win)' : 'var(--lose)';
          }
          if (bjBankrollEl) {
            bjBankrollEl.textContent = formatMoney(bankroll);
            bjBankrollEl.style.color = bankroll >= 0 ? 'var(--win)' : 'var(--lose)';
          }
        }

        // Define segments and payout multipliers (relative to bet amount)
        const segments = 12;
        const multipliers = [0, 0, 0.4, 1, 0, 2, 0, 4, 0, 10, 0, 20];
        const colors = ['#26a69a', '#ef5350']; // alternating colors (teal/red)
        const radius = canvas.width / 2;
        const center = { x: radius, y: radius };

        function drawWheel() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const arc = (2 * Math.PI) / segments;
          for (let i = 0; i < segments; i++) {
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.fillStyle = (i % 2 === 0) ? colors[0] : colors[1];
            ctx.arc(center.x, center.y, radius, i * arc, (i + 1) * arc);
            ctx.closePath();
            ctx.fill();

            // Label with payout (scaled by current bet)
            ctx.save();
            ctx.translate(center.x, center.y);
            ctx.rotate(i * arc + arc / 2);
            ctx.textAlign = 'right';
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            const betVal = getBet();
            const amount = Math.round(multipliers[i] * betVal);
            const label = amount <= 0 ? '$0' : `$${amount}`;
            ctx.fillText(label, radius - 12, 6);
            ctx.restore();
          }
        }

        drawWheel();

        let isSpinning = false;
        // SPIN_COST is dynamic based on bet input
        const SPIN_DURATION_MS = 7000;
        let lastFinalRotation = 0; // degrees (normalized 0..359)
        let lastTargetIndex = 0; // segment index selected for the spin
        let spinTimeoutId = null; // active spin timeout id
        let activeFinalRotation = 0; // full absolute rotation used for the running animation
        
        function getBet() {
          // Enforce natural number >= 1
          const raw = String(betInput && betInput.value || '5');
          const digitsOnly = raw.replace(/\D+/g, '');
          let val = parseInt(digitsOnly || '5', 10);
          if (!Number.isFinite(val) || val < 1) val = 1;
          if (betInput) betInput.value = String(val);
          return val;
        }
        // View helpers
        function showHome() {
          homeSection.style.display = '';
          homeHeader.style.display = '';
          document.getElementById('roulette-app').style.display = 'none';
          rouletteHeader.style.display = 'none';
          pokerApp.style.display = 'none';
          pokerHeader.style.display = 'none';
          blackjackApp.style.display = 'none';
          blackjackHeader.style.display = 'none';
        }
        function showRoulette() {
          homeSection.style.display = 'none';
          homeHeader.style.display = 'none';
          document.getElementById('roulette-app').style.display = '';
          rouletteHeader.style.display = '';
          pokerApp.style.display = 'none';
          pokerHeader.style.display = 'none';
          blackjackApp.style.display = 'none';
          blackjackHeader.style.display = 'none';
          updateSharedBankrollUI();
        }
        function showPoker() {
          homeSection.style.display = 'none';
          homeHeader.style.display = 'none';
          document.getElementById('roulette-app').style.display = 'none';
          rouletteHeader.style.display = 'none';
          pokerApp.style.display = 'block';
          pokerHeader.style.display = '';
          updateSharedBankrollUI();
        }
        function showBlackjack() {
          homeSection.style.display = 'none';
          homeHeader.style.display = 'none';
          document.getElementById('roulette-app').style.display = 'none';
          rouletteHeader.style.display = 'none';
          pokerApp.style.display = 'none';
          pokerHeader.style.display = 'none';
          blackjackApp.style.display = 'flex';
          blackjackHeader.style.display = '';
          updateSharedBankrollUI();
        }

        function formatMoney(amount) {
          const sign = amount < 0 ? '-' : '';
          const val = Math.abs(amount).toFixed(2);
          return `${sign}$${val}`;
        }

        function updateProfitDisplay() { updateSharedBankrollUI(); }

        function finalizeSpin() {
          if (!isSpinning) return;
          // Clear any running animation and timeout
          if (spinTimeoutId !== null) { clearTimeout(spinTimeoutId); spinTimeoutId = null; }
          canvas.style.transition = 'none';
          // Ensure the transition style takes effect before snapping
          void canvas.offsetWidth;

          // Snap to the exact end-of-animation rotation first
          canvas.style.transform = `rotate(${activeFinalRotation}deg)`;
          // Ensure the snap is applied
          void canvas.offsetWidth;

          // Sync normalized final rotation with the snapped absolute rotation to avoid any drift
          lastFinalRotation = ((activeFinalRotation % 360) + 360) % 360;

          // Determine winning index under top pointer using final rotation (normalized)
          const segmentAngleDeg = 360 / segments;
          const theta = ((90 + lastFinalRotation) % 360 + 360) % 360; // angle from right at top pointer
          const winningIndex = Math.floor(theta / segmentAngleDeg);
          const betNow = getBet();
          const payout = Math.round(multipliers[winningIndex] * betNow);
          if (payout > 0) {
            bankroll += payout;
            resultEl.textContent = `You won ${formatMoney(payout)}!`;
          } else {
            resultEl.textContent = 'No win this time.';
          }
          persistBankroll();
          updateProfitDisplay();
          // Normalize transform to keep values small so next transition always triggers
          canvas.style.transform = `rotate(${lastFinalRotation}deg)`;
          // Ensure normalization is applied so next transition can be set later
          void canvas.offsetWidth;
          // Force reflow to apply the non-animated transform before enabling next spin
          isSpinning = false;
          if (spinButton) spinButton.disabled = false;
          if (skipButton) skipButton.disabled = true;
        }

        function spin() {
          if (isSpinning) return;
          isSpinning = true;
          spinButton.disabled = true;
          if (skipButton) skipButton.disabled = false;
          resultEl.textContent = 'Spinning...';

          // Deduct cost immediately
          const SPIN_COST = getBet();
          bankroll -= SPIN_COST;
          persistBankroll();
          updateProfitDisplay();

          // Choose a random target segment
          const targetIndex = Math.floor(Math.random() * segments);
          const segmentAngle = 360 / segments;

          // Compute final rotation so pointer lands on targetIndex at the top
          // Pointer is at 0deg (top). Canvas labels are drawn starting from 0 rad to the right,
          // but we only care about evenly spaced segments. Offset by half-segment so label centers align.
          const margin = 2; // degrees safety margin from edges
          const randomExtra = (Math.random() * (segmentAngle - 2 * margin)) - (segmentAngle / 2 - margin); // centered within segment
          const targetCenter = targetIndex * segmentAngle + segmentAngle / 2; // from 0Â° at right
          // Pointer at top (90Â° from right)
          // CSS rotate() is clockwise-positive. To bring target to the top (90Â°),
          // rotate by (targetCenter + randomExtra - 90Â°).
          const alignToTop = (targetCenter + randomExtra) - 90;
          const extraSpins = 8; // strong spin
          const finalRotation = extraSpins * 360 + alignToTop;
          lastFinalRotation = ((finalRotation % 360) + 360) % 360; // normalize 0..359
          activeFinalRotation = finalRotation;
          lastTargetIndex = targetIndex;

          canvas.style.transition = `transform ${SPIN_DURATION_MS}ms cubic-bezier(0.23, 1, 0.32, 1)`;
          canvas.style.transform = `rotate(${finalRotation}deg)`;

          spinTimeoutId = setTimeout(() => {
            finalizeSpin();
          }, SPIN_DURATION_MS + 50);
        }

        updateProfitDisplay();
        // Recompute wheel labels when bet changes and enforce natural numbers
        if (betInput) {
          betInput.addEventListener('input', () => { getBet(); drawWheel(); });
          betInput.addEventListener('blur', () => { getBet(); drawWheel(); });
        }
        if (spinButton) spinButton.addEventListener('click', spin);
        if (skipButton) skipButton.addEventListener('click', () => { if (isSpinning) finalizeSpin(); });
        if (openRouletteBtn) openRouletteBtn.addEventListener('click', showRoulette);
        if (goHomeBtn) goHomeBtn.addEventListener('click', showHome);
        if (openBlackjackBtn) openBlackjackBtn.addEventListener('click', showBlackjack);
        if (bjHomeBtn) bjHomeBtn.addEventListener('click', showHome);

        // Blackjack implementation
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        // Bet is adjustable via input
        let bjDeck = [];
        let bjPlayer = [];
        let bjPlayer2 = null; // becomes an array after split
        let bjDealer = [];
        let roundActive = false;
        let dealerHoleHidden = true;
        let currentPlayerHand = 1; // 1 or 2 when split

        function buildDeck() {
          const d = [];
          for (const s of suits) {
            for (const r of ranks) {
              d.push({ rank: r, suit: s });
            }
          }
          return d;
        }
        function shuffle(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }
        function resetDeckIfNeeded() {
          if (bjDeck.length < 15) {
            bjDeck = buildDeck();
            shuffle(bjDeck);
          }
        }
        function drawCard() {
          return bjDeck.pop();
        }
        function handValue(hand) {
          let total = 0;
          let aces = 0;
          for (const c of hand) {
            if (c.rank === 'A') { aces += 1; total += 11; }
            else if (['K','Q','J'].includes(c.rank)) { total += 10; }
            else { total += parseInt(c.rank, 10); }
          }
          while (total > 21 && aces > 0) { total -= 10; aces -= 1; }
          return total;
        }
        function cardEl(card, faceDown=false) {
          const div = document.createElement('div');
          if (faceDown) {
            div.className = 'bj-card back';
            div.textContent = '';
            div.setAttribute('role', 'listitem');
            div.setAttribute('aria-label', 'Face-down card');
            return div;
          }
          const isRed = (card.suit === 'â™¥' || card.suit === 'â™¦');
          div.className = `bj-card ${isRed ? 'red' : 'black'}`;
          div.textContent = `${card.rank}${card.suit}`;
          div.setAttribute('role', 'listitem');
          const suitName = card.suit === 'â™¥' ? 'Hearts' : card.suit === 'â™¦' ? 'Diamonds' : card.suit === 'â™ ' ? 'Spades' : 'Clubs';
          const rankName = card.rank === 'A' ? 'Ace' : card.rank === 'K' ? 'King' : card.rank === 'Q' ? 'Queen' : card.rank === 'J' ? 'Jack' : card.rank;
          div.setAttribute('aria-label', `${rankName} of ${suitName}`);
          return div;
        }
        function renderHands() {
          bjDealerHandEl.innerHTML = '';
          bjPlayerHandEl.innerHTML = '';
          if (bjPlayerHandEl2) bjPlayerHandEl2.innerHTML = '';
          if (bjPlayerHandEl3) bjPlayerHandEl3.innerHTML = '';
          if (bjPlayerHandEl4) bjPlayerHandEl4.innerHTML = '';
          if (dealerHoleHidden && bjDealer.length > 1) {
            bjDealerHandEl.appendChild(cardEl(bjDealer[0]));
            bjDealerHandEl.appendChild(cardEl(bjDealer[1], true));
            for (let i = 2; i < bjDealer.length; i++) bjDealerHandEl.appendChild(cardEl(bjDealer[i]));
            bjDealerTotalEl.textContent = handValue([bjDealer[0]]) + ' + ?';
          } else {
            for (const c of bjDealer) bjDealerHandEl.appendChild(cardEl(c));
            bjDealerTotalEl.textContent = handValue(bjDealer);
          }
          for (const c of bjPlayer) bjPlayerHandEl.appendChild(cardEl(c));
          bjPlayerTotalEl.textContent = bjPlayer.length ? handValue(bjPlayer) : 'â€”';
          const row2 = document.getElementById('bj-player-row-2');
          if (bjPlayer2 && Array.isArray(bjPlayer2)) {
            if (row2) row2.style.display = '';
            if (bjPlayerHandEl2) bjPlayerHandEl2.style.display = '';
            for (const c of bjPlayer2) bjPlayerHandEl2.appendChild(cardEl(c));
            if (bjPlayerTotalEl2) bjPlayerTotalEl2.textContent = bjPlayer2.length ? handValue(bjPlayer2) : 'â€”';
          } else {
            if (row2) row2.style.display = 'none';
            if (bjPlayerHandEl2) bjPlayerHandEl2.style.display = 'none';
            if (bjPlayerTotalEl2) bjPlayerTotalEl2.textContent = 'â€”';
          }
          const row3 = document.getElementById('bj-player-row-3');
          if (typeof bjPlayer3 !== 'undefined' && bjPlayer3 && Array.isArray(bjPlayer3)) {
            if (row3) row3.style.display = '';
            if (bjPlayerHandEl3) bjPlayerHandEl3.style.display = '';
            for (const c of bjPlayer3) bjPlayerHandEl3.appendChild(cardEl(c));
            if (bjPlayerTotalEl3) bjPlayerTotalEl3.textContent = bjPlayer3.length ? handValue(bjPlayer3) : 'â€”';
          } else {
            if (row3) row3.style.display = 'none';
            if (bjPlayerHandEl3) bjPlayerHandEl3.style.display = 'none';
            if (bjPlayerTotalEl3) bjPlayerTotalEl3.textContent = 'â€”';
          }
          const row4 = document.getElementById('bj-player-row-4');
          if (typeof bjPlayer4 !== 'undefined' && bjPlayer4 && Array.isArray(bjPlayer4)) {
            if (row4) row4.style.display = '';
            if (bjPlayerHandEl4) bjPlayerHandEl4.style.display = '';
            for (const c of bjPlayer4) bjPlayerHandEl4.appendChild(cardEl(c));
            if (bjPlayerTotalEl4) bjPlayerTotalEl4.textContent = bjPlayer4.length ? handValue(bjPlayer4) : 'â€”';
          } else {
            if (row4) row4.style.display = 'none';
            if (bjPlayerHandEl4) bjPlayerHandEl4.style.display = 'none';
            if (bjPlayerTotalEl4) bjPlayerTotalEl4.textContent = 'â€”';
          }
          // Indicate active hand
          bjPlayerHandEl.removeAttribute('aria-current');
          if (bjPlayerHandEl2) bjPlayerHandEl2.removeAttribute('aria-current');
          if (bjPlayerHandEl3) bjPlayerHandEl3.removeAttribute('aria-current');
          if (bjPlayerHandEl4) bjPlayerHandEl4.removeAttribute('aria-current');
          if (currentPlayerHand === 1) bjPlayerHandEl.setAttribute('aria-current', 'true');
          else if (currentPlayerHand === 2 && bjPlayerHandEl2) bjPlayerHandEl2.setAttribute('aria-current', 'true');
          else if (currentPlayerHand === 3 && bjPlayerHandEl3) bjPlayerHandEl3.setAttribute('aria-current', 'true');
          else if (currentPlayerHand === 4 && bjPlayerHandEl4) bjPlayerHandEl4.setAttribute('aria-current', 'true');
        }
        function setControls({ deal, hit, stand, split = false, next }) {
          // Enable/disable
          bjDealBtn.disabled = !deal;
          bjHitBtn.disabled = !hit;
          bjStandBtn.disabled = !stand;
          if (bjSplitBtn) bjSplitBtn.disabled = !split;
          bjNewBtn.disabled = !next;

          // Show/hide per usability
          // Deal: only before a round starts or after reset
          bjDealBtn.style.display = deal ? '' : 'none';
          // Split: only when it is actually available
          if (bjSplitBtn) bjSplitBtn.style.display = split ? '' : 'none';
          // New Round: only after a round has finished
          bjNewBtn.style.display = next ? '' : 'none';
        }
        function startRound() {
          bjStatusEl.textContent = '';
          const bjBet = getBjBet();
          if (bankroll < bjBet) {
            bjStatusEl.textContent = 'Insufficient bankroll.';
            setControls({ deal: true, hit: false, stand: false, split: false, next: false });
            return;
          }
          bankroll -= bjBet;
          persistBankroll();
          updateSharedBankrollUI();
          dealerHoleHidden = true;
          bjPlayer = [];
          bjPlayer2 = null;
          bjPlayer3 = null;
          bjPlayer4 = null;
          bjDealer = [];
          currentPlayerHand = 1;
          resetDeckIfNeeded();
          bjPlayer.push(drawCard());
          bjDealer.push(drawCard());
          bjPlayer.push(drawCard());
          bjDealer.push(drawCard());
          roundActive = true;
          const canSplit = bjPlayer.length === 2 && (bjPlayer[0].rank === bjPlayer[1].rank) && bankroll >= bjBet;
          setControls({ deal: false, hit: true, stand: true, split: canSplit, next: false });
          renderHands();
          const p = handValue(bjPlayer);
          const d = handValue(bjDealer);
          if (p === 21 || d === 21) resolveRound();
          // Move focus to Hit button for quick action
          if (!bjHitBtn.disabled) bjHitBtn.focus();
        }
        function resolveRound() {
          dealerHoleHidden = false;
          while (handValue(bjDealer) < 17) {
            bjDealer.push(drawCard());
          }
          const d = handValue(bjDealer);
          renderHands();
          let messages = [];
          function settleOne(hand, label) {
            const p = handValue(hand);
            if (p > 21) { messages.push(`${label}${label?': ':''}You bust. Dealer wins.`); return 0; }
            if (d > 21) { messages.push(`${label}${label?': ':''}Dealer busts. You win!`); return 2; }
            if (p > d) { messages.push(`${label}${label?': ':''}You win!`); return 2; }
            if (p < d) { messages.push(`${label}${label?': ':''}Dealer wins.`); return 0; }
            messages.push(`${label}${label?': ':''}Push (tie).`); return 1;
          }
          const bjBet = getBjBet();
          const hands = [bjPlayer, bjPlayer2, bjPlayer3, bjPlayer4].filter(h => Array.isArray(h) && h.length > 0);
          if (hands.length > 1) {
            hands.forEach((hand, idx) => {
              const r = settleOne(hand, `Hand ${idx + 1}`);
              bankroll += (r === 2 ? bjBet * 2 : r === 1 ? bjBet : 0);
            });
            bjStatusEl.textContent = messages.join(' ');
          } else {
            const r = settleOne(bjPlayer, '');
            if (r === 2) bankroll += bjBet * 2;
            if (r === 1) bankroll += bjBet;
            bjStatusEl.textContent = messages.join(' ').trim();
          }
          persistBankroll();
          updateSharedBankrollUI();
          roundActive = false;
          setControls({ deal: false, hit: false, stand: false, split: false, next: true });
          // Focus next action
          if (!bjNewBtn.disabled) bjNewBtn.focus();
        }

        bjDealBtn.addEventListener('click', () => { if (!roundActive) startRound(); });
        function nextHandIndex(from) {
          if (from < 1) return 1;
          for (let i = from + 1; i <= 4; i++) {
            if ((i === 2 && bjPlayer2 && bjPlayer2.length) || (i === 3 && bjPlayer3 && bjPlayer3.length) || (i === 4 && bjPlayer4 && bjPlayer4.length)) return i;
          }
          return -1;
        }
        function canSplitActive() {
          const bjBet = getBjBet();
          const hand = currentPlayerHand === 1 ? bjPlayer : currentPlayerHand === 2 ? bjPlayer2 : currentPlayerHand === 3 ? bjPlayer3 : bjPlayer4;
          const handsCount = (bjPlayer.length?1:0) + (bjPlayer2&&bjPlayer2.length?1:0) + (bjPlayer3&&bjPlayer3.length?1:0) + (bjPlayer4&&bjPlayer4.length?1:0);
          return hand && hand.length === 2 && hand[0].rank === hand[1].rank && bankroll >= bjBet && handsCount < 4;
        }
        bjHitBtn.addEventListener('click', () => {
          if (!roundActive) return;
          const hand = currentPlayerHand === 1 ? bjPlayer : currentPlayerHand === 2 ? bjPlayer2 : currentPlayerHand === 3 ? bjPlayer3 : bjPlayer4;
          hand.push(drawCard());
          renderHands();
          if (handValue(hand) >= 21) {
            const ni = nextHandIndex(currentPlayerHand);
            if (ni !== -1) {
              currentPlayerHand = ni;
              setControls({ deal: false, hit: true, stand: true, split: canSplitActive(), next: false });
              bjHitBtn.focus();
            } else {
              resolveRound();
            }
          } else {
            setControls({ deal: false, hit: true, stand: true, split: canSplitActive(), next: false });
          }
        });
        bjStandBtn.addEventListener('click', () => {
          if (!roundActive) return;
          const ni = nextHandIndex(currentPlayerHand);
          if (ni !== -1) {
            currentPlayerHand = ni;
            renderHands();
            setControls({ deal: false, hit: true, stand: true, split: canSplitActive(), next: false });
            bjHitBtn.focus();
            return;
          }
          resolveRound();
        });
        if (bjSplitBtn) bjSplitBtn.addEventListener('click', () => {
          if (!roundActive) return;
          if (!canSplitActive()) return;
          const bjBet = getBjBet();
          if (bankroll < bjBet) { bjStatusEl.textContent = 'Insufficient bankroll to split.'; return; }
          bankroll -= bjBet;
          persistBankroll();
          updateSharedBankrollUI();
          let hand = currentPlayerHand === 1 ? bjPlayer : currentPlayerHand === 2 ? bjPlayer2 : currentPlayerHand === 3 ? bjPlayer3 : bjPlayer4;
          const moved = hand.pop();
          if (!bjPlayer2 || !bjPlayer2.length) bjPlayer2 = [moved];
          else if (!bjPlayer3 || !bjPlayer3.length) bjPlayer3 = [moved];
          else bjPlayer4 = [moved];
          renderHands();
          setControls({ deal: false, hit: true, stand: true, split: canSplitActive(), next: false });
          bjHitBtn.focus();
        });
        bjNewBtn.addEventListener('click', () => {
          setControls({ deal: true, hit: false, stand: false, next: false });
          bjDealerHandEl.innerHTML = '';
          bjPlayerHandEl.innerHTML = '';
          if (bjPlayerHandEl2) bjPlayerHandEl2.innerHTML = '';
          if (bjPlayerHandEl3) bjPlayerHandEl3.innerHTML = '';
          if (bjPlayerHandEl4) bjPlayerHandEl4.innerHTML = '';
          bjDealerTotalEl.textContent = 'â€”';
          bjPlayerTotalEl.textContent = 'â€”';
          if (bjPlayerTotalEl2) bjPlayerTotalEl2.textContent = 'â€”';
          if (bjPlayerTotalEl3) bjPlayerTotalEl3.textContent = 'â€”';
          if (bjPlayerTotalEl4) bjPlayerTotalEl4.textContent = 'â€”';
          bjStatusEl.textContent = '';
          roundActive = false;
          bjPlayer = [];
          bjPlayer2 = null;
          bjPlayer3 = null;
          bjPlayer4 = null;
          currentPlayerHand = 1;
          bjDealBtn.focus();
        });
        resetDeckIfNeeded();
        setControls({ deal: true, hit: false, stand: false, next: false });
        if (openPokerBtn) openPokerBtn.addEventListener('click', () => { resetPoker(); showPoker(); });
        if (goHomePokerBtn) goHomePokerBtn.addEventListener('click', showHome);

        // Theme: load preference
        const savedTheme = localStorage.getItem('theme') || 'light';
        if (savedTheme === 'dark') {
          document.body.classList.add('dark');
          themeToggle.checked = true;
        }
        themeToggle.addEventListener('change', () => {
          if (themeToggle.checked) {
            document.body.classList.add('dark');
            localStorage.setItem('theme', 'dark');
          } else {
            document.body.classList.remove('dark');
            localStorage.setItem('theme', 'light');
          }
        });

        // Keyboard shortcuts for Blackjack: D=Deal, H=Hit, S=Stand, P=Split, N=New Round
        document.addEventListener('keydown', (e) => {
          const isBlackjackVisible = blackjackApp && blackjackApp.style.display !== 'none';
          if (!isBlackjackVisible) return;
          // ignore when focused on inputs or contenteditable
          const t = e.target;
          const tag = (t && t.tagName) ? t.tagName.toLowerCase() : '';
          if (tag === 'input' || tag === 'textarea' || (t && t.isContentEditable)) return;
          const key = e.key.toLowerCase();
          if (key === 'd' && !bjDealBtn.disabled) { e.preventDefault(); bjDealBtn.click(); }
          else if (key === 'h' && !bjHitBtn.disabled) { e.preventDefault(); bjHitBtn.click(); }
          else if (key === 's' && !bjStandBtn.disabled) { e.preventDefault(); bjStandBtn.click(); }
          else if (key === 'p' && bjSplitBtn && !bjSplitBtn.disabled) { e.preventDefault(); bjSplitBtn.click(); }
          else if (key === 'n' && !bjNewBtn.disabled) { e.preventDefault(); bjNewBtn.click(); }
        });

        // Start on home
        showHome();

        // Poker implementation (Texas Hold'em vs 4 computers)
        const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
        const RANK_VAL = Object.fromEntries(RANKS.map((r, i) => [r, i + 2]));
        const SMALL_BLIND = 3;
        const BIG_BLIND = 5;
        const NUM_PLAYERS = 5; // you + 4 computers

        let holdDeck = [];
        let players = [];
        let dealerIndex = 0;
        let community = [];
        let pot = 0;
        let street = 'preflop'; // preflop, flop, turn, river, showdown
        let currentIndex = 0;
        let currentBet = 0;
        let bets = [];
        let actedThisRound = new Set();
        let showdownReveal = false;
        let handInProgress = false;

        function buildHoldDeck() {
          holdDeck = [];
          for (const s of SUITS) for (const r of RANKS) holdDeck.push({ rank: r, suit: s, value: RANK_VAL[r] });
        }
        function shuffleInPlace(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
        function takeCard() { return holdDeck.pop(); }

        function createPlayers() {
          // index 0 is human and uses the shared bankroll
          const me = { id: 0, name: 'You', stack: bankroll, hole: [], folded: false, allin: false, isHuman: true };
          const ais = Array.from({ length: NUM_PLAYERS - 1 }, (_, i) => {
            const min = Math.max(1, Math.floor(bankroll * 0.10));
            const max = Math.max(min, Math.floor(bankroll * 2.00));
            const stack = Math.floor(min + Math.random() * (max - min + 1));
            return { id: i + 1, name: `CPU ${i + 1}`, stack, hole: [], folded: false, allin: false, isHuman: false };
          });
          players = [me, ...ais];
        }
        function syncHumanStackToBankroll() {
          players[0].stack = bankroll;
          updateSharedBankrollUI();
        }
        function renderSeats() {
          pokerSeatsEl.innerHTML = '';
          players.forEach((p, idx) => {
            const seat = document.createElement('div');
            seat.className = `seat${p.isHuman ? ' me' : ''}`;
            const header = document.createElement('div');
            header.className = 'seat-header';
            const nameEl = document.createElement('div'); nameEl.textContent = p.name;
            const right = document.createElement('div');
            if (idx === dealerIndex) { const d = document.createElement('span'); d.className = 'dealer'; d.textContent = 'D'; right.appendChild(d); }
            const stack = document.createElement('span'); stack.className = 'stack'; stack.textContent = formatMoney(p.stack);
            header.appendChild(nameEl); header.appendChild(stack); if (idx === dealerIndex) header.appendChild(right);
            const holeDiv = document.createElement('div'); holeDiv.className = 'hole';
            const hide = street !== 'showdown' && !p.isHuman;
            const cards = p.hole || [];
            for (let i = 0; i < 2; i++) {
              const c = cards[i];
              if (!c) { const x = document.createElement('div'); x.className = 'hidden-card'; holeDiv.appendChild(x); }
              else holeDiv.appendChild(cardNode(c, hide));
            }
            const status = document.createElement('div');
            status.style.fontSize = '12px'; status.style.color = 'var(--subtle)';
            status.textContent = p.folded ? 'Folded' : (p.allin ? 'All-in' : '');
            seat.appendChild(header); seat.appendChild(holeDiv); seat.appendChild(status);
            pokerSeatsEl.appendChild(seat);
          });
        }
        function cardNode(card, hidden=false) {
          if (hidden) { const div = document.createElement('div'); div.className = 'hidden-card'; return div; }
          const isRed = card.suit === 'â™¥' || card.suit === 'â™¦';
          const div = document.createElement('div'); div.className = `card-ui ${isRed ? 'red' : 'black'}`;
          const top = document.createElement('div'); top.className = 'card-top'; top.textContent = card.rank;
          const center = document.createElement('div'); center.className = 'card-center'; center.textContent = card.suit;
          const bottom = document.createElement('div'); bottom.className = 'card-bottom'; bottom.textContent = card.rank;
          div.appendChild(top); div.appendChild(center); div.appendChild(bottom); return div;
        }
        function renderCommunity() {
          pokerCommunityEl.innerHTML = '';
          community.forEach(c => pokerCommunityEl.appendChild(cardNode(c, false)));
        }
        function renderPotAndInfo() {
          pokerPotEl.textContent = `Pot: ${formatMoney(pot)}`;
          const toCall = Math.max(0, currentBet - (bets[0] || 0));
          toCallEl.textContent = formatMoney(toCall);
          pokerBankrollEl.textContent = formatMoney(bankroll);
        }
        function log(msg) { const p = document.createElement('div'); p.textContent = msg; pokerLogEl.appendChild(p); pokerLogEl.scrollTop = pokerLogEl.scrollHeight; }

        function resetHand() {
          pokerLogEl.innerHTML = '';
          community = []; pot = 0; street = 'preflop'; currentBet = 0; bets = Array(NUM_PLAYERS).fill(0); actedThisRound.clear(); showdownReveal = false;
          buildHoldDeck(); shuffleInPlace(holdDeck);
          players.forEach(p => { p.hole = [takeCard(), takeCard()]; p.folded = p.stack <= 0; p.allin = false; });
          postBlinds();
          renderAll();
          nextAction(findFirstToActPreflop());
          handInProgress = true;
          if (btnNewHand) btnNewHand.disabled = true;
        }
        function postBlinds() {
          const sbIndex = (dealerIndex + 1) % NUM_PLAYERS;
          const bbIndex = (dealerIndex + 2) % NUM_PLAYERS;
          betAmount(sbIndex, Math.min(SMALL_BLIND, players[sbIndex].stack));
          betAmount(bbIndex, Math.min(BIG_BLIND, players[bbIndex].stack));
          currentBet = Math.max(bets[sbIndex], bets[bbIndex]);
          log(`${players[sbIndex].name} posts ${formatMoney(bets[sbIndex])}; ${players[bbIndex].name} posts ${formatMoney(bets[bbIndex])}`);
        }
        function betAmount(i, amount) {
          const p = players[i];
          const put = Math.min(amount, p.stack);
          p.stack -= put; pot += put; bets[i] = (bets[i] || 0) + put;
          if (p.stack === 0) p.allin = true;
          if (i === 0) { bankroll = p.stack; persistBankroll(); }
        }
        function findFirstToActPreflop() { return (dealerIndex + 3) % NUM_PLAYERS; }
        function firstToActPostflop() { return (dealerIndex + 1) % NUM_PLAYERS; }
        function allNonFoldedActedAndEqualized() {
          let target = null;
          for (let i = 0; i < NUM_PLAYERS; i++) {
            const p = players[i];
            if (p.folded) continue;
            if (target === null) target = bets[i];
            if ((bets[i] !== target) && !p.allin) return false;
            if (!actedThisRound.has(i) && !p.allin) return false;
          }
          return true;
        }
        function advanceStreet() {
          actedThisRound.clear();
          currentBet = 0; bets = Array(NUM_PLAYERS).fill(0);
          if (street === 'preflop') { street = 'flop'; community.push(takeCard(), takeCard(), takeCard()); log('Flop dealt'); }
          else if (street === 'flop') { street = 'turn'; community.push(takeCard()); log('Turn dealt'); }
          else if (street === 'turn') { street = 'river'; community.push(takeCard()); log('River dealt'); }
          else { street = 'showdown'; showdown(); return; }
          renderAll();
          nextAction(firstToActPostflop());
        }
        function activePlayersCount() { return players.filter(p => !p.folded).length; }
        function nextAction(startAt) {
          currentIndex = startAt;
          for (let loop = 0; loop < 100; loop++) { // safety
            const p = players[currentIndex];
            if (!p.folded && !p.allin) break;
            currentIndex = (currentIndex + 1) % NUM_PLAYERS;
          }
          if (activePlayersCount() === 1) { street = 'showdown'; showdown(); return; }
          updateControlsForTurn();
          if (!players[currentIndex].isHuman) setTimeout(() => aiAct(currentIndex), 600);
        }
        function updateControlsForTurn() {
          const isMe = currentIndex === 0 && !players[0].folded && !players[0].allin && street !== 'showdown';
          const toCall = Math.max(0, currentBet - (bets[0] || 0));
          btnFold.disabled = !isMe;
          btnCheckCall.disabled = !isMe;
          btnRaise.disabled = !isMe;
          btnAllIn.disabled = !isMe;
          btnCheckCall.textContent = toCall > 0 ? `Call ${formatMoney(toCall)}` : 'Check';
          inputRaise.value = Math.max(currentBet + BIG_BLIND, 10);
          renderPotAndInfo();
        }
        function endTurnAndMaybeAdvance() {
          if (allNonFoldedActedAndEqualized()) advanceStreet();
          else nextAction((currentIndex + 1) % NUM_PLAYERS);
        }
        function humanFold() { players[0].folded = true; log('You fold'); renderSeats(); dealRemainingBoardAndShowdown(); }
        function humanCall() {
          const need = Math.max(0, currentBet - (bets[0] || 0));
          betAmount(0, need); log(`You call ${formatMoney(need)}`); renderPotAndInfo(); renderSeats(); actedThisRound.add(0); endTurnAndMaybeAdvance();
        }
        function humanRaise(toAmount) {
          const need = Math.max(0, currentBet - (bets[0] || 0));
          const raiseExtra = Math.max(0, toAmount - (bets[0] || 0) - need);
          const totalPut = need + raiseExtra;
          betAmount(0, totalPut);
          currentBet = Math.max(currentBet, (bets[0] || 0));
          log(`You raise to ${formatMoney(currentBet)}`);
          actedThisRound.clear(); actedThisRound.add(0);
          renderPotAndInfo(); renderSeats(); endTurnAndMaybeAdvance();
        }
        btnFold.addEventListener('click', () => { if (currentIndex===0) humanFold(); });
        btnCheckCall.addEventListener('click', () => { if (currentIndex===0) humanCall(); });
        btnRaise.addEventListener('click', () => {
          if (currentIndex!==0) return;
          const toVal = Math.max(currentBet + BIG_BLIND, parseInt(inputRaise.value||'0',10));
          humanRaise(toVal);
        });
        btnAllIn.addEventListener('click', () => { if (currentIndex===0) humanRaise(bets[0] + players[0].stack); });

        function aiStrength(idx) {
          const p = players[idx];
          const cards = [...community, ...p.hole];
          if (cards.length < 5) {
            // preflop heuristic: high card sum + pair bonus
            const v = p.hole.reduce((a,c)=>a+c.value,0) + (p.hole[0].rank===p.hole[1].rank?10:0);
            return v / 40; // ~0..1
          }
          return evaluateBestOfSeven(cards)[0] / 10; // scale 0..1
        }
        function aiAct(idx) {
          const p = players[idx];
          if (p.folded || p.allin) { endTurnAndMaybeAdvance(); return; }
          const toCall = Math.max(0, currentBet - (bets[idx] || 0));
          const str = aiStrength(idx) + (Math.random()*0.2 - 0.1);
          if (toCall === 0) {
            // bet or check
            if (str > 0.6 && p.stack > BIG_BLIND*2) {
              const raiseTo = Math.min((bets[idx]||0) + BIG_BLIND * (2 + Math.floor(str*4)), (bets[idx]||0) + p.stack);
              betAmount(idx, raiseTo - (bets[idx]||0)); currentBet = Math.max(currentBet, bets[idx]); log(`${p.name} bets to ${formatMoney(currentBet)}`); actedThisRound.clear(); actedThisRound.add(idx);
            } else {
              log(`${p.name} checks`); actedThisRound.add(idx);
            }
          } else {
            if (str < 0.35 && toCall > BIG_BLIND && Math.random() < 0.8) { p.folded = true; log(`${p.name} folds`); }
            else if (str > 0.7 && p.stack > toCall + BIG_BLIND*2 && Math.random() < 0.5) {
              const raiseTo = Math.min(currentBet + BIG_BLIND * (2 + Math.floor(str*5)), (bets[idx]||0) + p.stack);
              const put = raiseTo - (bets[idx]||0);
              betAmount(idx, put); currentBet = Math.max(currentBet, bets[idx]); log(`${p.name} raises to ${formatMoney(currentBet)}`); actedThisRound.clear(); actedThisRound.add(idx);
            } else {
              betAmount(idx, toCall); log(`${p.name} calls ${formatMoney(toCall)}`); actedThisRound.add(idx);
            }
          }
          renderSeats(); renderPotAndInfo();
          endTurnAndMaybeAdvance();
        }

        function evaluateFive(cards5) {
          // reuse 5-card ranking from earlier logic
          const values = cards5.map(c=>c.value).sort((a,b)=>a-b);
          const suitsLocal = cards5.map(c=>c.suit);
          const counts = new Map(); values.forEach(v=>counts.set(v,(counts.get(v)||0)+1));
          const entries = Array.from(counts.entries()).sort((a,b)=>b[1]-a[1]||b[0]-a[0]);
          const isFlush = new Set(suitsLocal).size===1;
          let isStraight=false, straightHigh=0; const uniq=[...new Set(values)];
          if (uniq.length===5){ const min=uniq[0], max=uniq[4]; if(max-min===4){isStraight=true; straightHigh=max;} if(JSON.stringify(uniq)==='[2,3,4,5,14]'){isStraight=true; straightHigh=5;} }
          if (isStraight && isFlush) return [9, straightHigh];
          if (entries[0][1]===4) return [8, entries[0][0], entries[1][0]];
          if (entries[0][1]===3 && entries[1][1]===2) return [7, entries[0][0], entries[1][0]];
          if (isFlush) return [6, ...values.slice().reverse()];
          if (isStraight) return [5, straightHigh];
          if (entries[0][1]===3) return [4, entries[0][0], ...values.filter(v=>v!==entries[0][0]).sort((a,b)=>b-a)];
          if (entries[0][1]===2 && entries[1][1]===2){ const ph=Math.max(entries[0][0],entries[1][0]); const pl=Math.min(entries[0][0],entries[1][0]); const k=values.find(v=>v!==entries[0][0]&&v!==entries[1][0]); return [3,ph,pl,k]; }
          if (entries[0][1]===2){ const pv=entries[0][0]; const ks=values.filter(v=>v!==pv).sort((a,b)=>b-a); return [2,pv,...ks]; }
          return [1, ...values.slice().reverse()];
        }
        function evaluateBestOfSeven(cards) {
          // choose best 5 of up to 7
          const picks = [];
          function comb(start, arr) {
            if (arr.length === 5) { picks.push(evaluateFive(arr)); return; }
            for (let i = start; i < cards.length; i++) comb(i+1, arr.concat(cards[i]));
          }
          comb(0, []);
          picks.sort((a,b)=> compareRanks(a,b));
          return picks[picks.length-1];
        }
        function compareRanks(a,b){ for(let i=0;i<Math.max(a.length,b.length);i++){ const av=a[i]||0, bv=b[i]||0; if(av!==bv) return av-bv; } return 0; }

        function showdown() {
          street = 'showdown';
          renderAll(true);
          const contenders = players.map((p,idx)=>({p,idx})).filter(x=>!x.p.folded);
          let best = null, winners = [];
          for (const {p,idx} of contenders) {
            const rank = evaluateBestOfSeven([...community, ...p.hole]);
            if (!best || compareRanks(rank,best)<0) { best = rank; winners = [idx]; }
            else if (compareRanks(rank,best)===0) winners.push(idx);
          }
          const share = pot / winners.length;
          winners.forEach(i=> { players[i].stack += share; if (i===0) bankroll = players[0].stack; });
          persistBankroll();
          log(`Showdown: ${winners.map(i=>players[i].name).join(', ')} win ${formatMoney(share)} each`);
          pokerStatusEl.textContent = 'Hand complete. Start a new hand when ready.';
          renderAll(true);
          handInProgress = false;
          if (btnNewHand) btnNewHand.disabled = false;
        }
        function renderAll(showdown=false) { renderSeats(); renderCommunity(); renderPotAndInfo(); }

        // Ensure Poker can be opened without errors and shows the interface
        function resetPoker() {
          // Initialize players and UI to a ready state without starting a hand
          createPlayers();
          syncHumanStackToBankroll();
          community = [];
          pot = 0;
          street = 'preflop';
          currentBet = 0;
          bets = Array(NUM_PLAYERS).fill(0);
          actedThisRound.clear();
          showdownReveal = false;
          dealerIndex = 0;
          pokerLogEl.innerHTML = '';
          pokerStatusEl.textContent = 'Click "New Hand" to start.';
          renderAll();
          handInProgress = false;
          if (btnNewHand) btnNewHand.disabled = false;
        }

        function dealRemainingBoardAndShowdown() {
          while (street !== 'showdown') {
            if (street === 'preflop') { street = 'flop'; community.push(takeCard(), takeCard(), takeCard()); }
            else if (street === 'flop') { street = 'turn'; community.push(takeCard()); }
            else if (street === 'turn') { street = 'river'; community.push(takeCard()); }
            else { break; }
          }
          renderAll(true);
          showdown();
        }

        btnNewHand.addEventListener('click', () => {
          if (handInProgress) { pokerStatusEl.textContent = 'Finish the current hand before dealing a new one.'; return; }
          syncHumanStackToBankroll();
          if (players.length===0) createPlayers();
          dealerIndex = (dealerIndex + 1) % NUM_PLAYERS;
          if (players[0].stack < BIG_BLIND) { pokerStatusEl.textContent = 'Not enough bankroll to play.'; return; }
          resetHand();
        });
      });
    </script>
  </body>
</html>
