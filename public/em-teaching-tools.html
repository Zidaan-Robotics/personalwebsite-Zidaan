<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>E&M Teaching Tools - Zidaan</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --bg-start: #e3f2fd;
      --bg-end: #f3e5f5;
      --text: rgba(0,0,0,0.87);
      --panel-bg: #ffffff;
      --panel-border: rgba(0,0,0,.06);
      --btn-start: #1e88e5;
      --btn-end: #3949ab;
      --accent: #1a237e;
      --subtle: rgba(0,0,0,.65);
    }
    body.dark {
      --bg-start: #000000;
      --bg-end: #0a0a0a;
      --text: rgba(255,255,255,0.98);
      --panel-bg: #050505;
      --panel-border: rgba(255,255,255,.2);
      --btn-start: #818cf8;
      --btn-end: #4f46e5;
      --accent: #c7d2fe;
      --subtle: rgba(255,255,255,.85);
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
      min-height: 100vh;
      padding: 2rem;
      color: var(--text);
    }
    .header {
      position: fixed;
      top: 0;
      right: 0;
      padding: 1rem;
      z-index: 10;
    }
    .toggle {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .toggle span {
      font-size: 14px;
      color: var(--subtle);
    }
    .switch {
      position: relative;
      width: 46px;
      height: 26px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #cfd8dc;
      transition: .2s;
      border-radius: 999px;
    }
    .slider:before {
      content: "";
      position: absolute;
      height: 20px;
      width: 20px;
      left: 3px;
      top: 3px;
      background: #fff;
      transition: .2s;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,.3);
    }
    input:checked + .slider {
      background: #37474f;
    }
    input:checked + .slider:before {
      transform: translateX(20px);
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 20px;
      padding: 3rem;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    h1 {
      color: var(--accent);
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }
    .content {
      line-height: 1.8;
      font-size: 1.1rem;
      color: var(--subtle);
      margin-bottom: 2rem;
    }
    .back-button {
      display: inline-block;
      padding: 0.75rem 2rem;
      font-size: 1rem;
      font-weight: 600;
      color: white;
      background: linear-gradient(135deg, var(--btn-start), var(--btn-end));
      border: none;
      border-radius: 50px;
      cursor: pointer;
      text-decoration: none;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .back-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    .back-button:active {
      transform: translateY(0);
    }
    .tools-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
      margin: 2rem 0;
    }
    .tool-card {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 1.5rem;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .tool-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    .tool-card h3 {
      color: var(--accent);
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }
    .tool-card p {
      color: var(--subtle);
      font-size: 0.9rem;
      line-height: 1.5;
    }
    .tool-section {
      display: none;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 20px;
      padding: 2rem;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      margin: 2rem 0;
    }
    .tool-section.active {
      display: block;
    }
    .tool-section h2 {
      color: var(--accent);
      margin-bottom: 1rem;
    }
    .tool-section p {
      color: var(--subtle);
      margin-bottom: 1.5rem;
      line-height: 1.6;
    }
    .canvas-container {
      background: #fff;
      border: 2px solid var(--panel-border);
      border-radius: 12px;
      margin: 1rem auto;
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    body.dark .canvas-container {
      background: #1a1a1a;
    }
    canvas {
      display: block;
      cursor: crosshair;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin: 1rem 0;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .control-group label {
      font-size: 0.9rem;
      color: var(--subtle);
    }
    .control-group input[type="number"],
    .control-group input[type="range"],
    .control-group select {
      padding: 0.5rem;
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      background: var(--panel-bg);
      color: var(--text);
      font-size: 0.9rem;
    }
    .control-group input[type="range"] {
      width: 150px;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
      height: 8px;
    }
    /* Track styling */
    .control-group input[type="range"]::-webkit-slider-runnable-track {
      background: var(--panel-border);
      height: 8px;
      border-radius: 4px;
    }
    .control-group input[type="range"]::-moz-range-track {
      background: var(--panel-border);
      height: 8px;
      border-radius: 4px;
    }
    /* Fill styling for Mozilla */
    .control-group input[type="range"]::-moz-range-progress {
      background: var(--accent);
      height: 8px;
      border-radius: 4px 0 0 4px;
    }
    /* Thumb styling */
    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      background: var(--accent);
      height: 18px;
      width: 18px;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px;
      position: relative;
      z-index: 1;
    }
    .control-group input[type="range"]::-moz-range-thumb {
      background: var(--accent);
      height: 18px;
      width: 18px;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      color: white;
      background: linear-gradient(135deg, var(--btn-start), var(--btn-end));
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    button:active {
      transform: translateY(0);
    }
    .info-box {
      background: rgba(26, 35, 126, 0.1);
      border-left: 4px solid var(--accent);
      padding: 1rem;
      border-radius: 6px;
      margin: 1rem 0;
      font-size: 0.9rem;
      color: var(--subtle);
    }
    body.dark .info-box {
      background: rgba(199, 210, 254, 0.1);
    }
    .overview-box {
      background: rgba(26, 35, 126, 0.08);
      border: 2px solid var(--accent);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      color: var(--subtle);
    }
    body.dark .overview-box {
      background: rgba(199, 210, 254, 0.08);
    }
    .overview-box h3 {
      color: var(--accent);
      font-size: 1.2rem;
      margin-bottom: 1rem;
      margin-top: 0;
    }
    .overview-box p {
      margin-bottom: 1rem;
      line-height: 1.7;
    }
    .overview-box p:last-child {
      margin-bottom: 0;
    }
    .overview-box ul {
      margin-left: 1.5rem;
      margin-bottom: 1rem;
      line-height: 1.7;
    }
    .overview-box li {
      margin-bottom: 0.5rem;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="toggle">
      <span>Dark Mode</span>
      <label class="switch">
        <input id="theme-toggle" type="checkbox" aria-label="Toggle dark mode">
        <span class="slider"></span>
      </label>
    </div>
  </div>
  <div class="container">
    <h1>E&M Teaching Tools</h1>
    <div class="tools-grid" id="tools-grid">
      <div class="tool-card" data-tool="electric-field">
        <h3>Electric Field</h3>
        <p>Visualize electric field lines around charges. Supports point, line, ring, and surface charges. Click to place charges.</p>
      </div>
      <div class="tool-card" data-tool="flux">
        <h3>Electric Flux</h3>
        <p>Explore how electric flux depends on field strength and surface orientation.</p>
      </div>
      <div class="tool-card" data-tool="voltage">
        <h3>Voltage & Equipotentials</h3>
        <p>See equipotential lines and understand voltage relationships.</p>
      </div>
      <div class="tool-card" data-tool="gauss">
        <h3>Gauss' Law</h3>
        <p>Discover how flux through a closed surface relates to enclosed charge.</p>
      </div>
    </div>

    <!-- Electric Field Tool Section -->
    <div class="tool-section" id="electric-field-section">
      <h2>Electric Field Visualization</h2>
      <div class="overview-box">
        <h3>What is an Electric Field?</h3>
        <p>An electric field is an invisible force field that surrounds any electric charge. Think of it like a gravitational field around a planet, but for electric charges instead of mass. The electric field describes how a charge would influence other charges placed nearby.</p>
        <p><strong>Key Concepts:</strong></p>
        <ul>
          <li><strong>Field Lines:</strong> Visual representations showing the direction and strength of the electric field. Lines point away from positive charges and toward negative charges.</li>
          <li><strong>Field Strength:</strong> The density of field lines indicates how strong the field is. Closer lines mean a stronger field.</li>
          <li><strong>Superposition:</strong> When multiple charges are present, their electric fields add together at each point in space.</li>
          <li><strong>Direction:</strong> The field direction shows which way a positive test charge would be pushed if placed at that location.</li>
        </ul>
        <p>Electric fields are fundamental to understanding how charges interact with each other and are the basis for many electrical phenomena, from static electricity to the operation of electronic devices.</p>
      </div>
      <p>Click on the canvas to place charges. Positive charges repel, negative charges attract. The field lines show the direction and strength of the electric field.</p>
      <div class="info-box">
        <strong>Formula:</strong> E = kq/r² where k = 9×10⁹ N⋅m²/C², q is charge, r is distance
      </div>
      <div class="controls">
        <div class="control-group">
          <label>Charge Type:</label>
          <select id="charge-type">
            <option value="positive">Positive (+)</option>
            <option value="negative">Negative (-)</option>
          </select>
        </div>
        <div class="control-group">
          <label>Charge Magnitude:</label>
          <input type="range" id="charge-magnitude" min="1" max="10" value="5" step="0.5">
          <span id="magnitude-value">5</span>
        </div>
        <button id="clear-field">Clear All</button>
        <div class="control-group">
          <label>
            <input type="checkbox" id="delete-mode"> Delete Mode (click charge to delete)
          </label>
        </div>
      </div>
      <div class="canvas-container">
        <canvas id="field-canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <!-- Flux Tool Section -->
    <div class="tool-section" id="flux-section">
      <h2>Electric Flux</h2>
      <div class="overview-box">
        <h3>What is Electric Flux?</h3>
        <p>Electric flux is a measure of how much electric field "flows" through a given surface. Imagine the electric field as a flow of invisible lines, and flux tells you how many of these lines pass through a surface.</p>
        <p><strong>Key Concepts:</strong></p>
        <ul>
          <li><strong>Surface Orientation:</strong> The angle between the electric field and the surface matters. Maximum flux occurs when the field is perpendicular to the surface; zero flux occurs when the field is parallel to the surface.</li>
          <li><strong>Field Strength:</strong> Stronger electric fields produce more flux through the same surface.</li>
          <li><strong>Surface Area:</strong> Larger surfaces can "catch" more field lines, resulting in greater flux.</li>
          <li><strong>Mathematical Relationship:</strong> Flux depends on the component of the electric field perpendicular to the surface, multiplied by the surface area.</li>
        </ul>
        <p>Electric flux is a crucial concept that leads to Gauss' Law, one of the four fundamental equations of electromagnetism. It helps us understand how electric fields interact with surfaces and is essential for calculating electric fields in symmetric situations.</p>
      </div>
      <p>Electric flux is the measure of electric field passing through a surface. Rotate the surface and see how the flux changes with angle.</p>
      <div class="info-box">
        <strong>Formula:</strong> Φ = E⋅A⋅cos(θ) where E is electric field, A is area, θ is angle between field and normal
      </div>
      <div class="controls">
        <div class="control-group">
          <label>View Mode:</label>
          <select id="flux-view-mode">
            <option value="2d">2D View</option>
            <option value="3d">3D View</option>
          </select>
        </div>
        <div class="control-group">
          <label>Shape Type:</label>
          <select id="flux-shape-type">
            <option value="rectangle">Rectangle</option>
            <option value="circle">Circle</option>
            <option value="triangle">Triangle</option>
            <option value="draw">Draw Custom Shape</option>
          </select>
        </div>
        <div class="control-group">
          <label>Field Type:</label>
          <select id="flux-field-type">
            <option value="uniform-vertical">Uniform Vertical</option>
            <option value="uniform-diagonal">Uniform Diagonal</option>
            <option value="nonuniform-radial">Nonuniform (Radial)</option>
            <option value="nonuniform-varying">Nonuniform (Varying Strength)</option>
          </select>
        </div>
        <div class="control-group" id="flux-field-strength-group">
          <label>Field Strength (N/C):</label>
          <input type="range" id="flux-field-strength" min="1" max="20" value="10" step="0.5">
          <span id="flux-field-value">10</span>
        </div>
        <div class="control-group" id="flux-field-angle-group" style="display: none;">
          <label>Field Angle (degrees):</label>
          <input type="range" id="flux-field-angle" min="0" max="360" value="90" step="5">
          <span id="flux-field-angle-value">90</span>°
        </div>
        <div class="control-group" id="flux-angle-group">
          <label>Surface Angle (degrees):</label>
          <input type="range" id="flux-angle" min="0" max="180" value="0" step="5">
          <span id="flux-angle-value">0</span>
        </div>
        <div class="control-group" id="flux-3d-controls" style="display: none;">
          <label>Rotation X (pitch):</label>
          <input type="range" id="flux-rotation-x" min="-90" max="90" value="0" step="5">
          <span id="flux-rotation-x-value">0</span>°
        </div>
        <div class="control-group" id="flux-3d-controls-y" style="display: none;">
          <label>Rotation Y (yaw):</label>
          <input type="range" id="flux-rotation-y" min="-180" max="180" value="0" step="5">
          <span id="flux-rotation-y-value">0</span>°
        </div>
        <button id="clear-flux-shape">Clear Shape</button>
      </div>
      <div class="info-box" id="flux-display" style="margin-top: 1rem; font-size: 1.1rem;">
        <strong>Electric Flux (Φ):</strong> <span id="flux-value">0.00</span> N⋅m²/C
      </div>
      <div class="canvas-container">
        <canvas id="flux-canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <!-- Voltage Tool Section -->
    <div class="tool-section" id="voltage-section">
      <h2>Voltage & Equipotential Lines</h2>
      <div class="overview-box">
        <h3>What is Voltage and What are Equipotential Lines?</h3>
        <p>Voltage (also called electric potential) is a measure of the electric potential energy per unit charge at a point in space. It tells you how much work would be needed to move a charge to that location from a reference point (usually infinity).</p>
        <p><strong>Key Concepts:</strong></p>
        <ul>
          <li><strong>Equipotential Lines:</strong> These are imaginary lines connecting all points that have the same voltage. No work is required to move a charge along an equipotential line.</li>
          <li><strong>Perpendicular Relationship:</strong> Equipotential lines are always perpendicular to electric field lines. This is because the electric field points in the direction of decreasing voltage (voltage gradient).</li>
          <li><strong>Spacing:</strong> Closer equipotential lines indicate a stronger electric field, just like contour lines on a map indicate steeper terrain.</li>
          <li><strong>Work and Energy:</strong> Moving a charge between different equipotential lines requires work. The voltage difference tells you how much energy is needed.</li>
        </ul>
        <p>Voltage is what drives electric current in circuits and is fundamental to understanding electrical energy. Equipotential surfaces help visualize how electric potential varies in space and are essential for understanding capacitors, batteries, and many other electrical devices.</p>
      </div>
      <p>Equipotential lines connect points of equal voltage. They are always perpendicular to electric field lines.</p>
      <div class="info-box">
        <strong>Formula:</strong> V = kq/r where V is voltage, k = 9×10⁹ N⋅m²/C², q is charge, r is distance
      </div>
      <div class="controls">
        <div class="control-group">
          <label>Charge Type:</label>
          <select id="voltage-charge-type">
            <option value="positive">Positive (+)</option>
            <option value="negative">Negative (-)</option>
          </select>
        </div>
        <div class="control-group">
          <label>Charge Magnitude:</label>
          <input type="range" id="voltage-charge-magnitude" min="1" max="10" value="5" step="0.5">
          <span id="voltage-magnitude-value">5</span>
        </div>
        <div class="control-group">
          <label>
            <input type="checkbox" id="voltage-delete-mode"> Delete Mode (click charge to delete)
          </label>
        </div>
        <button id="clear-voltage">Clear All</button>
      </div>
      <div class="canvas-container">
        <canvas id="voltage-canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <!-- Gauss' Law Tool Section -->
    <div class="tool-section" id="gauss-section">
      <h2>Gauss' Law</h2>
      <div class="overview-box">
        <h3>What is Gauss' Law?</h3>
        <p>Gauss' Law is one of the four fundamental equations of electromagnetism (Maxwell's equations). It provides a powerful relationship between electric fields and the charges that create them, stating that the total electric flux through any closed surface is proportional to the total charge enclosed within that surface.</p>
        <p><strong>Key Concepts:</strong></p>
        <ul>
          <li><strong>Closed Surface:</strong> A surface that completely encloses a volume, like a sphere, cylinder, or box. The surface must be closed for Gauss' Law to apply.</li>
          <li><strong>Enclosed Charge:</strong> Only charges inside the closed surface matter. Charges outside the surface don't affect the total flux through the surface.</li>
          <li><strong>Symmetry:</strong> Gauss' Law is most useful when there's symmetry in the charge distribution, allowing us to easily calculate electric fields that would be difficult to find otherwise.</li>
          <li><strong>Flux Independence:</strong> The total flux depends only on the enclosed charge, not on the size or shape of the closed surface (as long as it encloses the same charge).</li>
        </ul>
        <p>Gauss' Law is incredibly powerful because it allows us to calculate electric fields for symmetric charge distributions (like spheres, cylinders, and planes) much more easily than using Coulomb's law directly. It's a fundamental principle that connects the geometry of electric fields to the charges that create them.</p>
      </div>
      <p>Gauss' law states that the electric flux through a closed surface is proportional to the charge enclosed.</p>
      <div class="info-box">
        <strong>Gauss' Law:</strong> ∮ E · dA = Q_enc/ε₀ where Q_enc is enclosed charge, ε₀ = 8.85×10⁻¹² C²/N⋅m²
      </div>
      <div class="controls">
        <div class="control-group">
          <label>Charge Distribution Type:</label>
          <select id="gauss-charge-type">
            <option value="point">Point Charge</option>
            <option value="line">Line of Charge</option>
            <option value="cylinder">Cylinder of Charge</option>
            <option value="ring">Ring of Charge</option>
            <option value="plane">Plane of Charge</option>
          </select>
        </div>
        <div class="control-group" id="gauss-charge-group">
          <label id="gauss-charge-label">Point Charge (q):</label>
          <input type="range" id="gauss-charge" min="-10" max="10" value="5" step="0.5">
          <span id="gauss-charge-value">5</span> <span id="gauss-charge-unit">× 10⁻⁹ C</span>
        </div>
        <div class="control-group" id="gauss-charge-param-group" style="display: none;">
          <label id="gauss-charge-param-label"></label>
          <input type="range" id="gauss-charge-param" min="50" max="300" value="100" step="10">
          <span id="gauss-charge-param-value">100</span> <span id="gauss-charge-param-unit">px</span>
        </div>
        <div class="control-group">
          <label>Gaussian Surface Shape:</label>
          <select id="gauss-shape">
            <option value="sphere">Sphere</option>
            <option value="cylinder">Cylinder</option>
            <option value="ring">Ring</option>
          </select>
        </div>
        <div class="control-group">
          <label id="gauss-size-label">Radius (r):</label>
          <input type="range" id="gauss-radius" min="50" max="300" value="150" step="10">
          <span id="gauss-radius-value">150</span> px
        </div>
        <div class="control-group" id="gauss-height-group" style="display: none;">
          <label>Height (h):</label>
          <input type="range" id="gauss-height" min="100" max="400" value="200" step="10">
          <span id="gauss-height-value">200</span> px
        </div>
        <div class="control-group">
          <button id="gauss-toggle-calculation" style="margin-top: 0.5rem;">Show Calculation</button>
        </div>
      </div>
      <div class="formula-display" id="gauss-formula-display" style="background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 12px; padding: 1.5rem; margin: 1rem 0; font-family: 'Courier New', monospace; display: none;">
        <div style="font-size: 1.1rem; color: var(--accent); margin-bottom: 0.5rem; font-weight: bold;">Gauss' Law Evaluation:</div>
        <div id="gauss-formula-content" style="color: var(--subtle); line-height: 1.8; font-size: 1rem;"></div>
      </div>
      <div class="canvas-container">
        <canvas id="gauss-canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <a href="index.html" class="back-button">Back to Home</a>
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const themeToggle = document.getElementById('theme-toggle');
      const savedTheme = localStorage.getItem('theme') || 'light';
      if (savedTheme === 'dark') {
        document.body.classList.add('dark');
        themeToggle.checked = true;
      }
      themeToggle.addEventListener('change', () => {
        if (themeToggle.checked) {
          document.body.classList.add('dark');
          localStorage.setItem('theme', 'dark');
        } else {
          document.body.classList.remove('dark');
          localStorage.setItem('theme', 'light');
        }
        // Redraw Gauss canvas if it's initialized
        if (typeof gaussDrawFunction === 'function') {
          gaussDrawFunction();
        }
        // Update all slider fills after theme change
        updateAllSliderFills();
      });

      // Function to update slider fill visualization
      function updateSliderFill(slider) {
        if (!slider) return;
        const min = parseFloat(slider.min);
        const max = parseFloat(slider.max);
        const value = parseFloat(slider.value);
        
        // Calculate fill percentage (0 to 100%)
        const percent = ((value - min) / (max - min)) * 100;
        // Ensure it goes to 100% when at max
        const fillPercent = Math.min(100, Math.max(0, percent));
        
        // Get computed accent color
        const computedStyle = getComputedStyle(document.documentElement);
        const accentColor = computedStyle.getPropertyValue('--accent').trim();
        const trackColor = computedStyle.getPropertyValue('--panel-border').trim();
        
        // Update webkit slider track background
        slider.style.setProperty('--fill-percent', fillPercent + '%');
        
        // For webkit browsers, update the background gradient
        const trackStyle = `
          linear-gradient(to right,
            ${accentColor} 0%,
            ${accentColor} ${fillPercent}%,
            ${trackColor} ${fillPercent}%,
            ${trackColor} 100%
          )
        `;
        
        // Apply to webkit slider track via style element
        let styleId = 'slider-style-' + slider.id;
        let existingStyle = document.getElementById(styleId);
        if (!existingStyle) {
          existingStyle = document.createElement('style');
          existingStyle.id = styleId;
          document.head.appendChild(existingStyle);
        }
        existingStyle.textContent = `
          #${slider.id}::-webkit-slider-runnable-track {
            background: ${trackStyle} !important;
          }
        `;
      }
      
      // Function to update all slider fills
      function updateAllSliderFills() {
        const allSliders = document.querySelectorAll('input[type="range"]');
        allSliders.forEach(slider => {
          updateSliderFill(slider);
        });
      }
      
      // Use event delegation to update fills on all slider inputs
      document.addEventListener('input', function(e) {
        if (e.target && e.target.type === 'range') {
          updateSliderFill(e.target);
        }
      });
      
      // Initialize all slider fills after a short delay to ensure DOM is ready
      setTimeout(() => {
        updateAllSliderFills();
      }, 100);

      // Tool navigation - only show one section at a time
      window.currentTool = null;
      const toolCards = document.querySelectorAll('.tool-card');
      const toolSections = document.querySelectorAll('.tool-section');
      
      // Update fills when tool sections become visible
      const observer = new MutationObserver(() => {
        updateAllSliderFills();
      });
      toolSections.forEach(section => {
        observer.observe(section, { attributes: true, attributeFilter: ['class'] });
      });

      // Ensure all sections are hidden initially
      toolSections.forEach(section => {
        section.classList.remove('active');
      });

      toolCards.forEach(card => {
        card.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const tool = card.dataset.tool;
          if (!tool) {
            console.error('Tool card missing data-tool attribute!');
            return;
          }
          
          // Reset all cards opacity
          toolCards.forEach(c => {
            if (c) c.style.opacity = '1';
          });
          
          // Hide ALL sections first
          toolSections.forEach(s => {
            s.classList.remove('active');
          });
          
          // Show selected card and section
          card.style.opacity = '0.7';
          const targetSection = document.getElementById(`${tool}-section`);
          if (targetSection) {
            targetSection.classList.add('active');
            window.currentTool = tool;
            
            // Initialize tool if function exists
            if (tool === 'electric-field' && typeof initElectricField === 'function') {
              initElectricField();
            } else if (tool === 'flux' && typeof initFlux === 'function') {
              initFlux();
            } else if (tool === 'voltage' && typeof initVoltage === 'function') {
              initVoltage();
            } else if (tool === 'gauss' && typeof initGauss === 'function') {
              initGauss();
            }
            
            // Scroll to section smoothly
            setTimeout(() => {
              targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          } else {
            console.error(`Section not found: ${tool}-section`);
          }
        });
      });

      // Basic initialization functions for tools
      let fieldCanvasInitialized = false;
      let charges = [];
      let mouseX = 0;
      let mouseY = 0;
      
      function initElectricField() {
        const canvas = document.getElementById('field-canvas');
        if (!canvas || fieldCanvasInitialized) return;
        fieldCanvasInitialized = true;
        
        const ctx = canvas.getContext('2d');
        const isDark = document.body.classList.contains('dark');
        
        // Constants
        const k = 9e9; // Coulomb's constant (scaled for visualization)
        const fieldLineSpacing = 30; // Spacing between field lines
        const minFieldStrength = 0.1; // Minimum field strength to draw
        
        // Calculate electric field at a point
        function calculateField(x, y) {
          let Ex = 0, Ey = 0;
          for (const charge of charges) {
            const dx = x - charge.x;
            const dy = y - charge.y;
            const r2 = dx * dx + dy * dy;
            if (r2 < 1) continue; // Avoid division by zero
            
            const r = Math.sqrt(r2);
            const magnitude = (k * charge.q) / (r2 * 1e6); // Scale down for visualization
            Ex += magnitude * (dx / r);
            Ey += magnitude * (dy / r);
          }
          return { Ex, Ey, magnitude: Math.sqrt(Ex * Ex + Ey * Ey) };
        }
        
        // Draw a single field line
        function drawFieldLine(startX, startY, direction, chargeSign) {
          const steps = 500;
          const stepSize = 2;
          let x = startX;
          let y = startY;
          const path = [{x, y}];
          
          for (let i = 0; i < steps; i++) {
            const field = calculateField(x, y);
            if (field.magnitude < minFieldStrength) break;
            
            // Normalize field direction
            const len = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
            if (len < 0.01) break;
            
            const dx = (field.Ex / len) * stepSize * direction;
            const dy = (field.Ey / len) * stepSize * direction;
            
            x += dx;
            y += dy;
            
            // Check bounds
            if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) break;
            
            // Check if too close to any charge
            let tooClose = false;
            for (const charge of charges) {
              const dist = Math.sqrt((x - charge.x) ** 2 + (y - charge.y) ** 2);
              if (dist < 15) {
                tooClose = true;
                break;
              }
            }
            if (tooClose) break;
            
            path.push({x, y});
          }
          
          // Draw the field line
          if (path.length > 1) {
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
              ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
          }
        }
        
        // Draw all field lines
        function drawFieldLines() {
          if (charges.length === 0) return;
          
          ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.4)' : 'rgba(26, 35, 126, 0.4)';
          ctx.lineWidth = 1.5;
          
          // Draw field lines from each charge
          for (const charge of charges) {
            const numLines = Math.max(8, Math.floor(Math.abs(charge.q) * 2));
            const angleStep = (2 * Math.PI) / numLines;
            
            if (charge.q > 0) {
              // Positive charges: start near charge, trace outward
              for (let i = 0; i < numLines; i++) {
                const angle = i * angleStep;
                const startRadius = 20 + Math.abs(charge.q) * 3;
                const startX = charge.x + Math.cos(angle) * startRadius;
                const startY = charge.y + Math.sin(angle) * startRadius;
                drawFieldLine(startX, startY, 1, 1);
              }
            } else {
              // Negative charges: start far from charge, trace inward
              for (let i = 0; i < numLines; i++) {
                const angle = i * angleStep;
                const distances = [
                  Math.min(canvas.width, canvas.height) * 0.45,
                  Math.min(canvas.width, canvas.height) * 0.35,
                  Math.min(canvas.width, canvas.height) * 0.25
                ];
                
                for (const maxDist of distances) {
                  const startX = charge.x + Math.cos(angle) * maxDist;
                  const startY = charge.y + Math.sin(angle) * maxDist;
                  
                  if (startX >= 10 && startX <= canvas.width - 10 && 
                      startY >= 10 && startY <= canvas.height - 10) {
                    drawFieldLine(startX, startY, 1, -1);
                    break;
                  }
                }
              }
            }
          }
        }
        
        // Main draw function
        function draw() {
          // Clear canvas
          ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw charges first (background layer)
          for (const charge of charges) {
            const radius = 10 + Math.abs(charge.q) * 2;
            ctx.beginPath();
            ctx.arc(charge.x, charge.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = charge.q > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            ctx.fill();
            ctx.strokeStyle = isDark ? '#fff' : '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(charge.q > 0 ? '+' : '-', charge.x, charge.y + 5);
          }
          
          // Draw field lines on top of charges
          drawFieldLines();
          
          // Draw electric field at mouse position
          if (mouseX >= 0 && mouseY >= 0 && mouseX <= canvas.width && mouseY <= canvas.height) {
            const field = calculateField(mouseX, mouseY);
            if (field.magnitude > 0.01) {
              const scale = 50;
              const arrowLength = Math.min(field.magnitude * scale, 100);
              const angle = Math.atan2(field.Ey, field.Ex);
              
              ctx.strokeStyle = isDark ? '#fbbf24' : '#f59e0b';
              ctx.fillStyle = isDark ? '#fbbf24' : '#f59e0b';
              ctx.lineWidth = 2;
              
              // Draw arrow
              ctx.beginPath();
              ctx.moveTo(mouseX, mouseY);
              ctx.lineTo(
                mouseX + arrowLength * Math.cos(angle),
                mouseY + arrowLength * Math.sin(angle)
              );
              ctx.stroke();
              
              // Draw arrowhead
              const arrowSize = 8;
              ctx.beginPath();
              ctx.moveTo(
                mouseX + arrowLength * Math.cos(angle),
                mouseY + arrowLength * Math.sin(angle)
              );
              ctx.lineTo(
                mouseX + arrowLength * Math.cos(angle) - arrowSize * Math.cos(angle - Math.PI / 6),
                mouseY + arrowLength * Math.sin(angle) - arrowSize * Math.sin(angle - Math.PI / 6)
              );
              ctx.lineTo(
                mouseX + arrowLength * Math.cos(angle) - arrowSize * Math.cos(angle + Math.PI / 6),
                mouseY + arrowLength * Math.sin(angle) - arrowSize * Math.sin(angle + Math.PI / 6)
              );
              ctx.closePath();
              ctx.fill();
              
              // Draw magnitude text
              ctx.fillStyle = isDark ? '#fbbf24' : '#f59e0b';
              ctx.font = '12px Arial';
              const magnitudeText = `E = ${field.magnitude.toFixed(2)} N/C`;
              const textWidth = ctx.measureText(magnitudeText).width;
              const textHeight = 20;
              const padding = 5;
              
              let textX = mouseX + arrowLength * Math.cos(angle) + 10;
              let textY = mouseY + arrowLength * Math.sin(angle) + 5;
              
              if (textX + textWidth + padding > canvas.width) {
                textX = mouseX - textWidth - padding - 10;
              }
              if (textX < padding) {
                textX = padding;
              }
              if (textY + textHeight > canvas.height) {
                textY = mouseY - arrowLength * Math.sin(angle) - textHeight - 5;
              }
              if (textY < textHeight) {
                textY = textHeight;
              }
              
              ctx.fillRect(textX - padding, textY - textHeight + padding, textWidth + padding * 2, textHeight);
              ctx.textAlign = 'left';
              ctx.fillStyle = isDark ? '#000' : '#fff';
              ctx.fillText(magnitudeText, textX, textY);
            }
          }
        }
        
        // Update magnitude display
        document.getElementById('charge-magnitude').addEventListener('input', (e) => {
          document.getElementById('magnitude-value').textContent = e.target.value;
        });
        
        // Mouse move handler for field display
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          mouseX = e.clientX - rect.left;
          mouseY = e.clientY - rect.top;
          draw();
        });
        
        canvas.addEventListener('mouseleave', () => {
          mouseX = -1;
          mouseY = -1;
          draw();
        });
        
        // Add click handler
        canvas.addEventListener('click', (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const deleteMode = document.getElementById('delete-mode').checked;
          
          if (deleteMode) {
            // Delete mode: check if click is on a charge
            for (let i = charges.length - 1; i >= 0; i--) {
              const charge = charges[i];
              const radius = 10 + Math.abs(charge.q) * 2;
              const dx = x - charge.x;
              const dy = y - charge.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance <= radius + 5) { // Small tolerance for easier clicking
                charges.splice(i, 1);
                draw();
                return;
              }
            }
          } else {
            // Add mode: add a new charge
            const type = document.getElementById('charge-type').value;
            const magnitude = parseFloat(document.getElementById('charge-magnitude').value);
            
            charges.push({
              x: x,
              y: y,
              q: type === 'positive' ? magnitude : -magnitude
            });
            
            draw();
          }
        });
        
        // Clear button
        document.getElementById('clear-field').addEventListener('click', () => {
          charges = [];
          mouseX = -1;
          mouseY = -1;
          draw();
        });
        
        // Initial draw
        draw();
        
        // Expose redraw function globally for re-activation
        window.redrawElectricField = draw;
      }

      let fluxCanvasInitialized = false;
      function initFlux() {
        const canvas = document.getElementById('flux-canvas');
        if (!canvas || fluxCanvasInitialized) return;
        fluxCanvasInitialized = true;
        
        const ctx = canvas.getContext('2d');
        const isDark = document.body.classList.contains('dark');
        
        // Shape state
        let currentShape = {
          type: 'rectangle',
          centerX: canvas.width / 2,
          centerY: canvas.height / 2,
          width: 200,
          height: 100,
          radius: 80,
          angle: 0,
          points: []
        };
        
        let isDrawing = false;
        let drawingPoints = [];
        
        // Calculate area of a polygon using shoelace formula
        function calculatePolygonArea(points) {
          if (points.length < 3) return 0;
          let area = 0;
          for (let i = 0; i < points.length; i++) {
            const j = (i + 1) % points.length;
            area += points[i].x * points[j].y;
            area -= points[j].x * points[i].y;
          }
          return Math.abs(area) / 2;
        }
        
        // 3D rotation functions
        function rotateX(point, angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          return {
            x: point.x,
            y: point.y * cos - point.z * sin,
            z: point.y * sin + point.z * cos
          };
        }
        
        function rotateY(point, angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          return {
            x: point.x * cos + point.z * sin,
            y: point.y,
            z: -point.x * sin + point.z * cos
          };
        }
        
        // Project 3D point to 2D screen coordinates
        function project3D(point, cameraZ) {
          const scale = cameraZ / (cameraZ + point.z);
          return {
            x: point.x * scale + canvas.width / 2,
            y: point.y * scale + canvas.height / 2,
            z: point.z
          };
        }
        
        // Get electric field at a point (x, y) in 2D canvas coordinates
        function getFieldAtPoint(x, y) {
          const fieldType = document.getElementById('flux-field-type').value;
          let fieldStrength;
          
          if (fieldType === 'nonuniform-radial' || fieldType === 'nonuniform-varying') {
            fieldStrength = 10;
          } else {
            fieldStrength = parseFloat(document.getElementById('flux-field-strength').value);
          }
          
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          
          if (fieldType === 'uniform-vertical') {
            return { 
              x: 0, 
              y: -fieldStrength, 
              magnitude: fieldStrength 
            };
          } else if (fieldType === 'uniform-diagonal') {
            const fieldAngle = parseFloat(document.getElementById('flux-field-angle').value) * Math.PI / 180;
            return {
              x: fieldStrength * Math.cos(fieldAngle),
              y: fieldStrength * Math.sin(fieldAngle),
              magnitude: fieldStrength
            };
          } else if (fieldType === 'nonuniform-radial') {
            const dx = x - centerX;
            const dy = y - centerY;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 1) dist = 1;
            const strength = fieldStrength * (100 / dist);
            return {
              x: (dx / dist) * strength,
              y: (dy / dist) * strength,
              magnitude: strength
            };
          } else if (fieldType === 'nonuniform-varying') {
            const dx = x - centerX;
            const dy = y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const variation1 = Math.sin(dist / 40) * 0.6;
            const variation2 = Math.cos((x + y) / 60) * 0.4;
            const variation3 = Math.sin(x / 80) * Math.cos(y / 80) * 0.3;
            const variation = 1 + variation1 + variation2 + variation3;
            const clampedVariation = Math.max(0.3, Math.min(2.3, variation));
            const strength = fieldStrength * clampedVariation;
            return {
              x: 0,
              y: -strength,
              magnitude: strength
            };
          }
          
          return { x: 0, y: -fieldStrength, magnitude: fieldStrength };
        }
        
        // Calculate flux
        function calculateFlux() {
          const fieldType = document.getElementById('flux-field-type').value;
          let fieldStrength;
          
          if (fieldType === 'nonuniform-radial' || fieldType === 'nonuniform-varying') {
            fieldStrength = 10;
          } else {
            fieldStrength = parseFloat(document.getElementById('flux-field-strength').value);
          }
          
          const shapeType = document.getElementById('flux-shape-type').value;
          const viewMode = document.getElementById('flux-view-mode').value;
          let area = 0;
          
          if (shapeType === 'rectangle') {
            area = currentShape.width * currentShape.height;
          } else if (shapeType === 'circle') {
            area = Math.PI * currentShape.radius * currentShape.radius;
          } else if (shapeType === 'triangle') {
            const side = currentShape.width;
            area = (Math.sqrt(3) / 4) * side * side;
          } else if (shapeType === 'draw' && currentShape.points.length >= 3) {
            area = calculatePolygonArea(currentShape.points);
          }
          
          const areaM2 = area * 0.0001;
          
          let flux = 0;
          
          if (fieldType === 'nonuniform-radial' || fieldType === 'nonuniform-varying') {
            const numSamples = 100;
            let totalFlux = 0;
            
            if (shapeType === 'rectangle') {
              const w = currentShape.width;
              const h = currentShape.height;
              const samplesPerSide = Math.floor(Math.sqrt(numSamples));
              for (let i = 0; i < samplesPerSide; i++) {
                for (let j = 0; j < samplesPerSide; j++) {
                  const x = currentShape.centerX - w/2 + (i / samplesPerSide) * w;
                  const y = currentShape.centerY - h/2 + (j / samplesPerSide) * h;
                  const field = getFieldAtPoint(x, y);
                  const normal = { x: 0, y: -1 };
                  const dot = field.x * normal.x + field.y * normal.y;
                  totalFlux += dot;
                }
              }
              flux = (totalFlux / numSamples) * areaM2;
            } else if (shapeType === 'circle') {
              const r = currentShape.radius;
              for (let i = 0; i < numSamples; i++) {
                const angle = (i / numSamples) * Math.PI * 2;
                const dist = Math.random() * r;
                const x = currentShape.centerX + Math.cos(angle) * dist;
                const y = currentShape.centerY + Math.sin(angle) * dist;
                const field = getFieldAtPoint(x, y);
                const normal = { x: 0, y: -1 };
                const dot = field.x * normal.x + field.y * normal.y;
                totalFlux += dot;
              }
              flux = (totalFlux / numSamples) * areaM2;
            } else {
              const field = getFieldAtPoint(currentShape.centerX, currentShape.centerY);
              const normal = { x: 0, y: -1 };
              const dot = field.x * normal.x + field.y * normal.y;
              flux = dot * areaM2;
            }
          } else {
            let angle = 0;
            let fieldVec = { x: 0, y: -1 };
            
            if (fieldType === 'uniform-diagonal') {
              const fieldAngle = parseFloat(document.getElementById('flux-field-angle').value) * Math.PI / 180;
              fieldVec = {
                x: Math.cos(fieldAngle),
                y: Math.sin(fieldAngle)
              };
            }
            
            if (viewMode === '3d') {
              const rotX = parseFloat(document.getElementById('flux-rotation-x').value) * Math.PI / 180;
              const rotY = parseFloat(document.getElementById('flux-rotation-y').value) * Math.PI / 180;
              
              let normal = { x: 0, y: 0, z: 1 };
              normal = rotateX(normal, rotX);
              normal = rotateY(normal, rotY);
              
              const fieldVec3D = { x: fieldVec.x, y: fieldVec.y, z: 0 };
              
              const dot = fieldVec3D.x * normal.x + fieldVec3D.y * normal.y + fieldVec3D.z * normal.z;
              angle = Math.acos(Math.max(-1, Math.min(1, dot)));
            } else {
              angle = parseFloat(document.getElementById('flux-angle').value) * Math.PI / 180;
              
              if (shapeType === 'circle') {
                angle = 0;
              } else if (shapeType === 'draw' && currentShape.points.length >= 3) {
                let avgNormalX = 0, avgNormalY = 0;
                for (let i = 0; i < currentShape.points.length; i++) {
                  const j = (i + 1) % currentShape.points.length;
                  const dx = currentShape.points[j].x - currentShape.points[i].x;
                  const dy = currentShape.points[j].y - currentShape.points[i].y;
                  const len = Math.sqrt(dx * dx + dy * dy);
                  if (len > 0) {
                    avgNormalX += -dy / len;
                    avgNormalY += dx / len;
                  }
                }
                const normalLen = Math.sqrt(avgNormalX * avgNormalX + avgNormalY * avgNormalY);
                if (normalLen > 0) {
                  avgNormalX /= normalLen;
                  avgNormalY /= normalLen;
                }
                const dot = fieldVec.x * avgNormalX + fieldVec.y * avgNormalY;
                angle = Math.acos(Math.max(-1, Math.min(1, dot)));
              }
            }
            
            flux = fieldStrength * areaM2 * Math.cos(angle);
          }
          
          return { flux, area, areaM2 };
        }
        
        // Helper function to draw an arrow with optional thickness based on field strength
        function drawArrow(x1, y1, x2, y2, thickness = 2) {
          const oldLineWidth = ctx.lineWidth;
          const oldLineCap = ctx.lineCap;
          const oldLineJoin = ctx.lineJoin;
          const oldStrokeStyle = ctx.strokeStyle;
          const oldFillStyle = ctx.fillStyle;
          
          // Set line properties for thicker, smoother arrows
          ctx.lineWidth = thickness;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // Calculate arrowhead size proportional to thickness for better visual balance
          const angle = Math.atan2(y2 - y1, x2 - x1);
          // Scale arrowhead length and width with thickness
          const arrowLength = Math.max(8, thickness * 1.5);
          const arrowAngle = Math.PI / 6 + (thickness > 4 ? 0.1 : 0); // Slightly wider for thicker arrows
          
          // Draw the arrow shaft, stopping slightly before the end to connect smoothly with arrowhead
          const shaftEndOffset = thickness * 0.3; // Shorten shaft slightly for better connection
          const shaftEndX = x2 - shaftEndOffset * Math.cos(angle);
          const shaftEndY = y2 - shaftEndOffset * Math.sin(angle);
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(shaftEndX, shaftEndY);
          ctx.stroke();
          
          // Draw arrowhead as a filled triangle that matches the line thickness
          // The arrowhead should look like a natural extension of the thick line
          ctx.beginPath();
          ctx.moveTo(x2, y2);
          ctx.lineTo(
            x2 - arrowLength * Math.cos(angle - arrowAngle),
            y2 - arrowLength * Math.sin(angle - arrowAngle)
          );
          ctx.lineTo(
            x2 - arrowLength * Math.cos(angle + arrowAngle),
            y2 - arrowLength * Math.sin(angle + arrowAngle)
          );
          ctx.closePath();
          ctx.fill();
          
          // Restore original properties
          ctx.lineWidth = oldLineWidth;
          ctx.lineCap = oldLineCap;
          ctx.lineJoin = oldLineJoin;
          ctx.strokeStyle = oldStrokeStyle;
          ctx.fillStyle = oldFillStyle;
        }
        
        // Helper function to calculate arrow thickness based on field strength
        function getArrowThickness(fieldMagnitude, minStrength = 1, maxStrength = 20) {
          // Map field magnitude to thickness range (1.5px to 6px)
          const normalized = (fieldMagnitude - minStrength) / (maxStrength - minStrength);
          const clamped = Math.max(0, Math.min(1, normalized));
          return 1.5 + clamped * 4.5; // Range from 1.5 to 6
        }
        
        // Draw field lines based on field type
        function drawFieldLines(viewMode, cameraZ) {
          const fieldType = document.getElementById('flux-field-type').value;
          ctx.strokeStyle = isDark ? 'rgba(110, 231, 183, 0.4)' : 'rgba(38, 166, 154, 0.4)';
          ctx.fillStyle = isDark ? 'rgba(110, 231, 183, 0.6)' : 'rgba(38, 166, 154, 0.6)';
          ctx.lineWidth = 2;
          
          if (fieldType === 'uniform-vertical') {
            const fieldStrength = parseFloat(document.getElementById('flux-field-strength').value);
            const arrowThickness = getArrowThickness(fieldStrength);
            for (let x = 50; x < canvas.width; x += 40) {
              if (viewMode === '3d') {
                for (let y = 50; y < canvas.height; y += 80) {
                  const start3D = { x: x - canvas.width / 2, y: y - canvas.height / 2, z: 0 };
                  const end3D = { x: x - canvas.width / 2, y: y - canvas.height / 2 - 30, z: 0 };
                  const start2D = project3D(start3D, cameraZ);
                  const end2D = project3D(end3D, cameraZ);
                  drawArrow(start2D.x, start2D.y, end2D.x, end2D.y, arrowThickness);
                }
              } else {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                for (let y = 30; y < canvas.height; y += 60) {
                  drawArrow(x, y, x, y - 15, arrowThickness);
                }
              }
            }
          } else if (fieldType === 'uniform-diagonal') {
            const fieldAngle = parseFloat(document.getElementById('flux-field-angle').value) * Math.PI / 180;
            const fieldStrength = parseFloat(document.getElementById('flux-field-strength').value);
            const arrowThickness = getArrowThickness(fieldStrength);
            const spacing = 40;
            const perpAngle = fieldAngle + Math.PI / 2;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const diagonal = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
            const numLines = Math.ceil(diagonal / spacing) + 4;
            
            for (let i = -numLines; i <= numLines; i++) {
              const offset = i * spacing;
              const cosPerp = Math.cos(perpAngle);
              const sinPerp = Math.sin(perpAngle);
              const lineDirX = Math.cos(fieldAngle);
              const lineDirY = Math.sin(fieldAngle);
              const pointOnLineX = centerX + cosPerp * offset;
              const pointOnLineY = centerY + sinPerp * offset;
              
              const intersections = [];
              
              if (Math.abs(lineDirY) > 0.001) {
                const t = (0 - pointOnLineY) / lineDirY;
                const x = pointOnLineX + lineDirX * t;
                if (x >= 0 && x <= canvas.width && t >= -diagonal && t <= diagonal) {
                  intersections.push({ x, y: 0 });
                }
                const t2 = (canvas.height - pointOnLineY) / lineDirY;
                const x2 = pointOnLineX + lineDirX * t2;
                if (x2 >= 0 && x2 <= canvas.width && t2 >= -diagonal && t2 <= diagonal) {
                  intersections.push({ x: x2, y: canvas.height });
                }
              }
              
              if (Math.abs(lineDirX) > 0.001) {
                const t = (0 - pointOnLineX) / lineDirX;
                const y = pointOnLineY + lineDirY * t;
                if (y >= 0 && y <= canvas.height && t >= -diagonal && t <= diagonal) {
                  intersections.push({ x: 0, y });
                }
                const t2 = (canvas.width - pointOnLineX) / lineDirX;
                const y2 = pointOnLineY + lineDirY * t2;
                if (y2 >= 0 && y2 <= canvas.height && t2 >= -diagonal && t2 <= diagonal) {
                  intersections.push({ x: canvas.width, y: y2 });
                }
              }
              
              const uniqueIntersections = [];
              for (const pt of intersections) {
                let isDuplicate = false;
                for (const existing of uniqueIntersections) {
                  if (Math.abs(pt.x - existing.x) < 0.1 && Math.abs(pt.y - existing.y) < 0.1) {
                    isDuplicate = true;
                    break;
                  }
                }
                if (!isDuplicate) {
                  uniqueIntersections.push(pt);
                }
              }
              
              if (uniqueIntersections.length >= 2) {
                let maxDist = 0;
                let bestPair = [uniqueIntersections[0], uniqueIntersections[1]];
                for (let j = 0; j < uniqueIntersections.length; j++) {
                  for (let k = j + 1; k < uniqueIntersections.length; k++) {
                    const dist = Math.sqrt(
                      (uniqueIntersections[j].x - uniqueIntersections[k].x) ** 2 +
                      (uniqueIntersections[j].y - uniqueIntersections[k].y) ** 2
                    );
                    if (dist > maxDist) {
                      maxDist = dist;
                      bestPair = [uniqueIntersections[j], uniqueIntersections[k]];
                    }
                  }
                }
                
                const startX = bestPair[0].x;
                const startY = bestPair[0].y;
                const endX = bestPair[1].x;
                const endY = bestPair[1].y;
                
                if (viewMode === '3d') {
                  const start3D = { x: startX - canvas.width / 2, y: startY - canvas.height / 2, z: 0 };
                  const end3D = { x: endX - canvas.width / 2, y: endY - canvas.height / 2, z: 0 };
                  const start2D = project3D(start3D, cameraZ);
                  const end2D = project3D(end3D, cameraZ);
                  ctx.beginPath();
                  ctx.moveTo(start2D.x, start2D.y);
                  ctx.lineTo(end2D.x, end2D.y);
                  ctx.stroke();
                  
                  const lineLength = Math.sqrt((end2D.x - start2D.x) ** 2 + (end2D.y - start2D.y) ** 2);
                  const numArrows = Math.max(1, Math.floor(lineLength / 50));
                  for (let j = 1; j <= numArrows; j++) {
                    const t = j / (numArrows + 1);
                    const arrowX = start2D.x + (end2D.x - start2D.x) * t;
                    const arrowY = start2D.y + (end2D.y - start2D.y) * t;
                    const arrowEndX = arrowX + Math.cos(fieldAngle) * 20;
                    const arrowEndY = arrowY + Math.sin(fieldAngle) * 20;
                    drawArrow(arrowX, arrowY, arrowEndX, arrowEndY, arrowThickness);
                  }
                } else {
                  ctx.beginPath();
                  ctx.moveTo(startX, startY);
                  ctx.lineTo(endX, endY);
                  ctx.stroke();
                  
                  const lineLength = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
                  const numArrows = Math.max(1, Math.floor(lineLength / 50));
                  for (let j = 1; j <= numArrows; j++) {
                    const t = j / (numArrows + 1);
                    const arrowX = startX + (endX - startX) * t;
                    const arrowY = startY + (endY - startY) * t;
                    const arrowEndX = arrowX + Math.cos(fieldAngle) * 20;
                    const arrowEndY = arrowY + Math.sin(fieldAngle) * 20;
                    drawArrow(arrowX, arrowY, arrowEndX, arrowEndY, arrowThickness);
                  }
                }
              }
            }
          } else if (fieldType === 'nonuniform-radial') {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 12) {
              const maxR = Math.min(canvas.width, canvas.height) / 2 - 20;
              const startR = 20;
              const startX = centerX + Math.cos(angle) * startR;
              const startY = centerY + Math.sin(angle) * startR;
              const endX = centerX + Math.cos(angle) * maxR;
              const endY = centerY + Math.sin(angle) * maxR;
              
              // Calculate field strength at arrow position (closer to center = stronger)
              const arrowR = startR + (maxR - startR) * 0.7;
              const arrowX = centerX + Math.cos(angle) * arrowR;
              const arrowY = centerY + Math.sin(angle) * arrowR;
              const field = getFieldAtPoint(arrowX, arrowY);
              const arrowThickness = getArrowThickness(field.magnitude, 3, 50); // Radial fields vary more
              
              if (viewMode === '3d') {
                const start3D = { x: startX - centerX, y: startY - centerY, z: 0 };
                const end3D = { x: endX - centerX, y: endY - centerY, z: 0 };
                const start2D = project3D(start3D, cameraZ);
                const end2D = project3D(end3D, cameraZ);
                ctx.beginPath();
                ctx.moveTo(start2D.x, start2D.y);
                ctx.lineTo(end2D.x, end2D.y);
                ctx.stroke();
                
                const arrowX2D = start2D.x + (end2D.x - start2D.x) * 0.7;
                const arrowY2D = start2D.y + (end2D.y - start2D.y) * 0.7;
                const arrowEndX = arrowX2D + Math.cos(angle) * 15;
                const arrowEndY = arrowY2D + Math.sin(angle) * 15;
                drawArrow(arrowX2D, arrowY2D, arrowEndX, arrowEndY, arrowThickness);
              } else {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                const arrowEndX = arrowX + Math.cos(angle) * 15;
                const arrowEndY = arrowY + Math.sin(angle) * 15;
                drawArrow(arrowX, arrowY, arrowEndX, arrowEndY, arrowThickness);
              }
            }
          } else if (fieldType === 'nonuniform-varying') {
            const baseStrength = 10;
            const minStrength = 3;
            const maxStrength = 23;
            
            for (let x = 50; x < canvas.width; x += 40) {
              for (let y = 50; y < canvas.height; y += 60) {
                const field = getFieldAtPoint(x, y);
                const intensity = (field.magnitude - minStrength) / (maxStrength - minStrength);
                const clampedIntensity = Math.max(0, Math.min(1, intensity));
                
                ctx.globalAlpha = 0.3 + clampedIntensity * 0.5;
                const arrowThickness = getArrowThickness(field.magnitude, minStrength, maxStrength);
                const arrowLength = 10 + clampedIntensity * 20;
                
                if (viewMode === '3d') {
                  const start3D = { x: x - canvas.width / 2, y: y - canvas.height / 2, z: 0 };
                  const end3D = { x: x - canvas.width / 2, y: y - canvas.height / 2 - arrowLength, z: 0 };
                  const start2D = project3D(start3D, cameraZ);
                  const end2D = project3D(end3D, cameraZ);
                  drawArrow(start2D.x, start2D.y, end2D.x, end2D.y, arrowThickness);
                } else {
                  drawArrow(x, y, x, y - arrowLength, arrowThickness);
                }
              }
            }
            ctx.globalAlpha = 1;
            ctx.lineWidth = 2;
          }
        }
        
        function drawFlux() {
          ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          const viewMode = document.getElementById('flux-view-mode').value;
          const shapeType = document.getElementById('flux-shape-type').value;
          const cameraZ = 800;
          
          drawFieldLines(viewMode, cameraZ);
          
          if (viewMode === '3d') {
            const rotX = parseFloat(document.getElementById('flux-rotation-x').value) * Math.PI / 180;
            const rotY = parseFloat(document.getElementById('flux-rotation-y').value) * Math.PI / 180;
            
            ctx.fillStyle = isDark ? 'rgba(129, 140, 248, 0.3)' : 'rgba(26, 35, 126, 0.2)';
            ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.8)' : 'rgba(26, 35, 126, 0.8)';
            ctx.lineWidth = 3;
            
            let shapePoints3D = [];
            let normal3D = { x: 0, y: 0, z: 1 };
            
            if (shapeType === 'rectangle') {
              const w = currentShape.width / 2;
              const h = currentShape.height / 2;
              shapePoints3D = [
                { x: -w, y: -h, z: 0 },
                { x: w, y: -h, z: 0 },
                { x: w, y: h, z: 0 },
                { x: -w, y: h, z: 0 }
              ];
            } else if (shapeType === 'circle') {
              const numSides = 32;
              for (let i = 0; i < numSides; i++) {
                const angle = (i / numSides) * Math.PI * 2;
                shapePoints3D.push({
                  x: currentShape.radius * Math.cos(angle),
                  y: currentShape.radius * Math.sin(angle),
                  z: 0
                });
              }
            } else if (shapeType === 'triangle') {
              const side = currentShape.width;
              const height = (Math.sqrt(3) / 2) * side;
              shapePoints3D = [
                { x: 0, y: -height * 2/3, z: 0 },
                { x: -side / 2, y: height / 3, z: 0 },
                { x: side / 2, y: height / 3, z: 0 }
              ];
            }
            
            shapePoints3D = shapePoints3D.map(p => {
              let rotated = rotateX(p, rotX);
              rotated = rotateY(rotated, rotY);
              rotated.x += currentShape.centerX - canvas.width / 2;
              rotated.y += currentShape.centerY - canvas.height / 2;
              return rotated;
            });
            normal3D = rotateX(normal3D, rotX);
            normal3D = rotateY(normal3D, rotY);
            
            const shapePoints2D = shapePoints3D.map(p => project3D(p, cameraZ));
            
            if (shapePoints2D.length > 0) {
              ctx.beginPath();
              ctx.moveTo(shapePoints2D[0].x, shapePoints2D[0].y);
              for (let i = 1; i < shapePoints2D.length; i++) {
                ctx.lineTo(shapePoints2D[i].x, shapePoints2D[i].y);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            }
            
            const shapeCenterX = currentShape.centerX - canvas.width / 2;
            const shapeCenterY = currentShape.centerY - canvas.height / 2;
            const normalStart3D = { x: shapeCenterX, y: shapeCenterY, z: 0 };
            const normalEnd3D = {
              x: shapeCenterX + normal3D.x * 60,
              y: shapeCenterY + normal3D.y * 60,
              z: normal3D.z * 60
            };
            const normalStart2D = project3D(normalStart3D, cameraZ);
            const normalEnd2D = project3D(normalEnd3D, cameraZ);
            
            ctx.strokeStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
            ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(normalStart2D.x, normalStart2D.y);
            ctx.lineTo(normalEnd2D.x, normalEnd2D.y);
            ctx.stroke();
            
            const normalAngle = Math.atan2(normalEnd2D.y - normalStart2D.y, normalEnd2D.x - normalStart2D.x);
            ctx.beginPath();
            ctx.moveTo(normalEnd2D.x, normalEnd2D.y);
            ctx.lineTo(normalEnd2D.x - 8 * Math.cos(normalAngle - Math.PI / 6), normalEnd2D.y - 8 * Math.sin(normalAngle - Math.PI / 6));
            ctx.lineTo(normalEnd2D.x - 8 * Math.cos(normalAngle + Math.PI / 6), normalEnd2D.y - 8 * Math.sin(normalAngle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.9)' : 'rgba(245, 158, 11, 0.9)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('n', normalEnd2D.x + 10, normalEnd2D.y);
            
          } else {
            const angle = parseFloat(document.getElementById('flux-angle').value) * Math.PI / 180;
            
            ctx.save();
            ctx.translate(currentShape.centerX, currentShape.centerY);
            ctx.rotate(angle);
            
            ctx.fillStyle = isDark ? 'rgba(129, 140, 248, 0.3)' : 'rgba(26, 35, 126, 0.2)';
            ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.8)' : 'rgba(26, 35, 126, 0.8)';
            ctx.lineWidth = 3;
            
            if (shapeType === 'rectangle') {
              ctx.fillRect(-currentShape.width / 2, -currentShape.height / 2, currentShape.width, currentShape.height);
              ctx.strokeRect(-currentShape.width / 2, -currentShape.height / 2, currentShape.width, currentShape.height);
            } else if (shapeType === 'circle') {
              ctx.beginPath();
              ctx.arc(0, 0, currentShape.radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            } else if (shapeType === 'triangle') {
              ctx.beginPath();
              const side = currentShape.width;
              const height = (Math.sqrt(3) / 2) * side;
              ctx.moveTo(0, -height * 2/3);
              ctx.lineTo(-side / 2, height / 3);
              ctx.lineTo(side / 2, height / 3);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            } else if (shapeType === 'draw' && currentShape.points.length >= 3) {
              ctx.restore();
              ctx.save();
              ctx.translate(currentShape.centerX, currentShape.centerY);
              
              ctx.beginPath();
              const transformedPoints = currentShape.points.map(p => ({
                x: p.x - currentShape.centerX,
                y: p.y - currentShape.centerY
              }));
              
              ctx.moveTo(transformedPoints[0].x, transformedPoints[0].y);
              for (let i = 1; i < transformedPoints.length; i++) {
                ctx.lineTo(transformedPoints[i].x, transformedPoints[i].y);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            }
            
            if (shapeType !== 'draw') {
              ctx.strokeStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
              ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(0, -60);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(0, -60);
              ctx.lineTo(-5, -50);
              ctx.lineTo(5, -50);
              ctx.closePath();
              ctx.fill();
              ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.9)' : 'rgba(245, 158, 11, 0.9)';
              ctx.font = '12px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('n', 0, -75);
            }
            
            ctx.restore();
          }
          
          const { flux } = calculateFlux();
          document.getElementById('flux-value').textContent = flux.toFixed(2);
        }
        
        // Handle view mode change
        document.getElementById('flux-view-mode').addEventListener('change', (e) => {
          const viewMode = e.target.value;
          const angleGroup = document.getElementById('flux-angle-group');
          const controls3D = document.getElementById('flux-3d-controls');
          const controls3DY = document.getElementById('flux-3d-controls-y');
          const shapeTypeSelect = document.getElementById('flux-shape-type');
          const drawOption = shapeTypeSelect.querySelector('option[value="draw"]');
          
          if (viewMode === '3d') {
            angleGroup.style.display = 'none';
            controls3D.style.display = 'flex';
            controls3DY.style.display = 'flex';
            
            if (drawOption) {
              drawOption.disabled = true;
            }
            
            if (shapeTypeSelect.value === 'draw') {
              shapeTypeSelect.value = 'rectangle';
              currentShape.type = 'rectangle';
              currentShape.width = 200;
              currentShape.height = 100;
              currentShape.centerX = canvas.width / 2;
              currentShape.centerY = canvas.height / 2;
              currentShape.points = [];
              drawingPoints = [];
              canvas.style.cursor = 'move';
            }
          } else {
            angleGroup.style.display = 'flex';
            controls3D.style.display = 'none';
            controls3DY.style.display = 'none';
            
            if (drawOption) {
              drawOption.disabled = false;
            }
          }
          
          drawFlux();
        });
        
        document.getElementById('flux-rotation-x').addEventListener('input', (e) => {
          document.getElementById('flux-rotation-x-value').textContent = e.target.value;
          drawFlux();
        });
        
        document.getElementById('flux-rotation-y').addEventListener('input', (e) => {
          document.getElementById('flux-rotation-y-value').textContent = e.target.value;
          drawFlux();
        });
        
        document.getElementById('flux-field-type').addEventListener('change', (e) => {
          const fieldType = e.target.value;
          const fieldAngleGroup = document.getElementById('flux-field-angle-group');
          const fieldStrengthGroup = document.getElementById('flux-field-strength-group');
          
          if (fieldType === 'uniform-diagonal') {
            fieldAngleGroup.style.display = 'flex';
            fieldStrengthGroup.style.display = 'flex';
          } else if (fieldType === 'nonuniform-radial' || fieldType === 'nonuniform-varying') {
            fieldAngleGroup.style.display = 'none';
            fieldStrengthGroup.style.display = 'none';
          } else {
            fieldAngleGroup.style.display = 'none';
            fieldStrengthGroup.style.display = 'flex';
          }
          
          drawFlux();
        });
        
        document.getElementById('flux-field-angle').addEventListener('input', (e) => {
          document.getElementById('flux-field-angle-value').textContent = e.target.value;
          drawFlux();
        });
        
        document.getElementById('flux-shape-type').addEventListener('change', (e) => {
          const shapeType = e.target.value;
          const viewMode = document.getElementById('flux-view-mode').value;
          currentShape.type = shapeType;
          
          const angleGroup = document.getElementById('flux-angle-group');
          if (shapeType === 'draw' || viewMode === '3d') {
            angleGroup.style.display = 'none';
            currentShape.angle = 0;
          } else {
            angleGroup.style.display = 'flex';
          }
          
          if (shapeType === 'draw') {
            canvas.style.cursor = 'crosshair';
          } else {
            canvas.style.cursor = 'move';
          }
          
          if (shapeType === 'rectangle') {
            currentShape.width = 200;
            currentShape.height = 100;
            currentShape.centerX = canvas.width / 2;
            currentShape.centerY = canvas.height / 2;
          } else if (shapeType === 'circle') {
            currentShape.radius = 80;
            currentShape.centerX = canvas.width / 2;
            currentShape.centerY = canvas.height / 2;
          } else if (shapeType === 'triangle') {
            currentShape.width = 150;
            currentShape.centerX = canvas.width / 2;
            currentShape.centerY = canvas.height / 2;
          } else if (shapeType === 'draw') {
            currentShape.points = [];
            drawingPoints = [];
          }
          
          drawFlux();
        });
        
        canvas.addEventListener('mousedown', (e) => {
          const viewMode = document.getElementById('flux-view-mode').value;
          const shapeType = document.getElementById('flux-shape-type').value;
          
          if (shapeType === 'draw' && viewMode === '2d') {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawingPoints = [{ x, y }];
            currentShape.points = [{ x, y }];
            currentShape.centerX = x;
            currentShape.centerY = y;
          } else if (viewMode === '3d' || shapeType !== 'draw') {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const dx = mouseX - currentShape.centerX;
            const dy = mouseY - currentShape.centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (shapeType === 'circle') {
              if (dist <= currentShape.radius) {
                isDrawing = true;
              }
            } else {
              const halfW = currentShape.width / 2;
              const halfH = currentShape.height / 2;
              if (Math.abs(dx) <= halfW && Math.abs(dy) <= halfH) {
                isDrawing = true;
              }
            }
          }
        });
        
        canvas.addEventListener('mousemove', (e) => {
          if (isDrawing) {
            const viewMode = document.getElementById('flux-view-mode').value;
            const shapeType = document.getElementById('flux-shape-type').value;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (shapeType === 'draw' && viewMode === '2d') {
              drawingPoints.push({ x, y });
              currentShape.points = [...drawingPoints];
              
              if (currentShape.points.length > 0) {
                let sumX = 0, sumY = 0;
                currentShape.points.forEach(p => {
                  sumX += p.x;
                  sumY += p.y;
                });
                currentShape.centerX = sumX / currentShape.points.length;
                currentShape.centerY = sumY / currentShape.points.length;
              }
            } else if (viewMode === '2d' && shapeType !== 'draw') {
              currentShape.centerX = x;
              currentShape.centerY = y;
            }
            
            drawFlux();
          }
        });
        
        canvas.addEventListener('mouseup', () => {
          isDrawing = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
          isDrawing = false;
        });
        
        document.getElementById('clear-flux-shape').addEventListener('click', () => {
          const shapeType = document.getElementById('flux-shape-type').value;
          currentShape.points = [];
          drawingPoints = [];
          currentShape.centerX = canvas.width / 2;
          currentShape.centerY = canvas.height / 2;
          if (shapeType === 'rectangle') {
            currentShape.width = 200;
            currentShape.height = 100;
          } else if (shapeType === 'circle') {
            currentShape.radius = 80;
          } else if (shapeType === 'triangle') {
            currentShape.width = 150;
          }
          drawFlux();
        });
        
        canvas.style.cursor = 'move';
        
        drawFlux();
        document.getElementById('flux-field-strength').addEventListener('input', (e) => {
          document.getElementById('flux-field-value').textContent = e.target.value;
          drawFlux();
        });
        document.getElementById('flux-angle').addEventListener('input', (e) => {
          document.getElementById('flux-angle-value').textContent = e.target.value;
          drawFlux();
        });
      }

      let voltageCanvasInitialized = false;
      let voltageCharges = [];
      let voltageMouseX = 0;
      let voltageMouseY = 0;
      
      function initVoltage() {
        const canvas = document.getElementById('voltage-canvas');
        if (!canvas || voltageCanvasInitialized) return;
        voltageCanvasInitialized = true;
        
        const ctx = canvas.getContext('2d');
        const isDark = document.body.classList.contains('dark');
        
        const k = 9e9; // Coulomb's constant (scaled)
        
        // Calculate voltage at a point
        function calculateVoltage(x, y) {
          let voltage = 0;
          for (const charge of voltageCharges) {
            const dx = x - charge.x;
            const dy = y - charge.y;
            const r = Math.sqrt(dx * dx + dy * dy);
            if (r < 1) r = 1; // Avoid division by zero
            voltage += (k * charge.q) / (r * 1e6); // Scale down for visualization
          }
          return voltage;
        }
        
        // Calculate electric field at a point
        function calculateField(x, y) {
          let Ex = 0, Ey = 0;
          for (const charge of voltageCharges) {
            const dx = x - charge.x;
            const dy = y - charge.y;
            const r2 = dx * dx + dy * dy;
            if (r2 < 1) continue;
            const r = Math.sqrt(r2);
            const magnitude = (k * charge.q) / (r2 * 1e6);
            Ex += magnitude * (dx / r);
            Ey += magnitude * (dy / r);
          }
          return { Ex, Ey, magnitude: Math.sqrt(Ex * Ex + Ey * Ey) };
        }
        
        // Draw equipotential lines
        function drawEquipotentials() {
          if (voltageCharges.length === 0) return;
          
          const numLevels = 15;
          const minV = -500;
          const maxV = 500;
          const step = (maxV - minV) / numLevels;
          
          ctx.strokeStyle = isDark ? 'rgba(168, 85, 247, 0.5)' : 'rgba(124, 58, 237, 0.5)';
          ctx.lineWidth = 1.5;
          
          for (let level = 0; level <= numLevels; level++) {
            const targetVoltage = minV + level * step;
            
            // Use marching squares-like algorithm to draw equipotential lines
            const gridSize = 10;
            const points = [];
            
            for (let x = 0; x < canvas.width; x += gridSize) {
              for (let y = 0; y < canvas.height; y += gridSize) {
                const v1 = calculateVoltage(x, y);
                const v2 = calculateVoltage(x + gridSize, y);
                const v3 = calculateVoltage(x + gridSize, y + gridSize);
                const v4 = calculateVoltage(x, y + gridSize);
                
                // Check if target voltage crosses any edge
                const edges = [];
                if ((v1 <= targetVoltage && v2 > targetVoltage) || (v1 > targetVoltage && v2 <= targetVoltage)) {
                  const t = (targetVoltage - v1) / (v2 - v1);
                  edges.push({ x: x + t * gridSize, y: y });
                }
                if ((v2 <= targetVoltage && v3 > targetVoltage) || (v2 > targetVoltage && v3 <= targetVoltage)) {
                  const t = (targetVoltage - v2) / (v3 - v2);
                  edges.push({ x: x + gridSize, y: y + t * gridSize });
                }
                if ((v3 <= targetVoltage && v4 > targetVoltage) || (v3 > targetVoltage && v4 <= targetVoltage)) {
                  const t = (targetVoltage - v3) / (v4 - v3);
                  edges.push({ x: x + (1 - t) * gridSize, y: y + gridSize });
                }
                if ((v4 <= targetVoltage && v1 > targetVoltage) || (v4 > targetVoltage && v1 <= targetVoltage)) {
                  const t = (targetVoltage - v4) / (v1 - v4);
                  edges.push({ x: x, y: y + (1 - t) * gridSize });
                }
                
                if (edges.length >= 2) {
                  ctx.beginPath();
                  ctx.moveTo(edges[0].x, edges[0].y);
                  ctx.lineTo(edges[1].x, edges[1].y);
                  ctx.stroke();
                }
              }
            }
          }
        }
        
        // Draw field lines
        function drawFieldLines() {
          if (voltageCharges.length === 0) return;
          
          ctx.strokeStyle = isDark ? 'rgba(110, 231, 183, 0.3)' : 'rgba(38, 166, 154, 0.3)';
          ctx.lineWidth = 1;
          
          for (const charge of voltageCharges) {
            const numLines = Math.max(8, Math.floor(Math.abs(charge.q) * 2));
            const angleStep = (2 * Math.PI) / numLines;
            
            for (let i = 0; i < numLines; i++) {
              const angle = i * angleStep;
              const startRadius = 20 + Math.abs(charge.q) * 3;
              const startX = charge.x + Math.cos(angle) * startRadius;
              const startY = charge.y + Math.sin(angle) * startRadius;
              
              let x = startX;
              let y = startY;
              const path = [{x, y}];
              
              for (let step = 0; step < 300; step++) {
                const field = calculateField(x, y);
                const len = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
                if (len < 0.01) break;
                
                const dx = (field.Ex / len) * 3 * (charge.q > 0 ? 1 : -1);
                const dy = (field.Ey / len) * 3 * (charge.q > 0 ? 1 : -1);
                
                x += dx;
                y += dy;
                
                if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) break;
                
                let tooClose = false;
                for (const c of voltageCharges) {
                  const dist = Math.sqrt((x - c.x) ** 2 + (y - c.y) ** 2);
                  if (dist < 15) {
                    tooClose = true;
                    break;
                  }
                }
                if (tooClose) break;
                
                path.push({x, y});
              }
              
              if (path.length > 1) {
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let j = 1; j < path.length; j++) {
                  ctx.lineTo(path[j].x, path[j].y);
                }
                ctx.stroke();
              }
            }
          }
        }
        
        function draw() {
          ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          drawEquipotentials();
          drawFieldLines();
          
          // Draw charges
          for (const charge of voltageCharges) {
            const radius = 10 + Math.abs(charge.q) * 2;
            ctx.beginPath();
            ctx.arc(charge.x, charge.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = charge.q > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            ctx.fill();
            ctx.strokeStyle = isDark ? '#fff' : '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(charge.q > 0 ? '+' : '-', charge.x, charge.y + 5);
          }
          
          // Draw voltage and field at mouse position
          if (voltageMouseX >= 0 && voltageMouseY >= 0 && voltageMouseX <= canvas.width && voltageMouseY <= canvas.height) {
            const voltage = calculateVoltage(voltageMouseX, voltageMouseY);
            const field = calculateField(voltageMouseX, voltageMouseY);
            
            if (field.magnitude > 0.01) {
              // Draw electric field vector
              const scale = 50;
              const arrowLength = Math.min(field.magnitude * scale, 100);
              const angle = Math.atan2(field.Ey, field.Ex);
              
              ctx.strokeStyle = isDark ? '#fbbf24' : '#f59e0b';
              ctx.fillStyle = isDark ? '#fbbf24' : '#f59e0b';
              ctx.lineWidth = 2;
              
              // Draw arrow
              ctx.beginPath();
              ctx.moveTo(voltageMouseX, voltageMouseY);
              ctx.lineTo(
                voltageMouseX + arrowLength * Math.cos(angle),
                voltageMouseY + arrowLength * Math.sin(angle)
              );
              ctx.stroke();
              
              // Draw arrowhead
              const arrowSize = 8;
              ctx.beginPath();
              ctx.moveTo(
                voltageMouseX + arrowLength * Math.cos(angle),
                voltageMouseY + arrowLength * Math.sin(angle)
              );
              ctx.lineTo(
                voltageMouseX + arrowLength * Math.cos(angle) - arrowSize * Math.cos(angle - Math.PI / 6),
                voltageMouseY + arrowLength * Math.sin(angle) - arrowSize * Math.sin(angle - Math.PI / 6)
              );
              ctx.lineTo(
                voltageMouseX + arrowLength * Math.cos(angle) - arrowSize * Math.cos(angle + Math.PI / 6),
                voltageMouseY + arrowLength * Math.sin(angle) - arrowSize * Math.sin(angle + Math.PI / 6)
              );
              ctx.closePath();
              ctx.fill();
            }
            
            // Draw voltage and field magnitude text
            ctx.fillStyle = isDark ? '#a855f7' : '#7c3aed';
            ctx.font = '12px Arial';
            const voltageText = `V = ${voltage.toFixed(2)} V`;
            const fieldText = field.magnitude > 0.01 ? `E = ${field.magnitude.toFixed(2)} N/C` : '';
            const textLines = field.magnitude > 0.01 ? [voltageText, fieldText] : [voltageText];
            
            let maxWidth = 0;
            for (const line of textLines) {
              const width = ctx.measureText(line).width;
              if (width > maxWidth) maxWidth = width;
            }
            
            const textHeight = 20;
            const padding = 5;
            const totalHeight = textLines.length * textHeight;
            
            let textX = voltageMouseX + 15;
            let textY = voltageMouseY - totalHeight / 2;
            
            if (textX + maxWidth + padding * 2 > canvas.width) {
              textX = voltageMouseX - maxWidth - padding * 2 - 15;
            }
            if (textX < padding) {
              textX = padding;
            }
            if (textY + totalHeight > canvas.height) {
              textY = canvas.height - totalHeight - padding;
            }
            if (textY < padding) {
              textY = padding;
            }
            
            // Draw background
            ctx.fillRect(textX - padding, textY - padding, maxWidth + padding * 2, totalHeight + padding * 2);
            
            // Draw text
            ctx.textAlign = 'left';
            ctx.fillStyle = isDark ? '#fff' : '#000';
            textLines.forEach((line, index) => {
              ctx.fillText(line, textX, textY + (index + 1) * textHeight);
            });
          }
        }
        
        // Update magnitude display
        document.getElementById('voltage-charge-magnitude').addEventListener('input', (e) => {
          document.getElementById('voltage-magnitude-value').textContent = e.target.value;
        });
        
        // Mouse move handler for voltage/field display
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          voltageMouseX = e.clientX - rect.left;
          voltageMouseY = e.clientY - rect.top;
          draw();
        });
        
        canvas.addEventListener('mouseleave', () => {
          voltageMouseX = -1;
          voltageMouseY = -1;
          draw();
        });
        
        // Click handler
        canvas.addEventListener('click', (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const deleteMode = document.getElementById('voltage-delete-mode').checked;
          
          if (deleteMode) {
            // Delete mode: check if click is on a charge
            for (let i = voltageCharges.length - 1; i >= 0; i--) {
              const charge = voltageCharges[i];
              const radius = 10 + Math.abs(charge.q) * 2;
              const dx = x - charge.x;
              const dy = y - charge.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              if (distance <= radius + 5) { // Small tolerance for easier clicking
                voltageCharges.splice(i, 1);
                draw();
                return;
              }
            }
          } else {
            // Add mode: add a new charge
            const type = document.getElementById('voltage-charge-type').value;
            const magnitude = parseFloat(document.getElementById('voltage-charge-magnitude').value);
            
            voltageCharges.push({
              x: x,
              y: y,
              q: type === 'positive' ? magnitude : -magnitude
            });
            
            draw();
          }
        });
        
        // Clear button
        document.getElementById('clear-voltage').addEventListener('click', () => {
          voltageCharges = [];
          voltageMouseX = -1;
          voltageMouseY = -1;
          draw();
        });
        
        draw();
      }

      let gaussCanvasInitialized = false;
      let gaussDrawFunction = null;
      
      function initGauss() {
        const canvas = document.getElementById('gauss-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const epsilon0 = 8.85e-12; // C²/N⋅m²
        const k = 9e9; // N⋅m²/C²
        const pxToM = 0.01; // Conversion: 1 px = 0.01 m (for visualization)
        
        function updateFormulaDisplay() {
          const isDark = document.body.classList.contains('dark');
          const chargeType = document.getElementById('gauss-charge-type').value;
          const charge = parseFloat(document.getElementById('gauss-charge').value);
          const chargeParam = document.getElementById('gauss-charge-param') ? parseFloat(document.getElementById('gauss-charge-param').value) : 0;
          const shape = document.getElementById('gauss-shape').value;
          const radius = parseFloat(document.getElementById('gauss-radius').value);
          const height = document.getElementById('gauss-height') ? parseFloat(document.getElementById('gauss-height').value) : 0;
          
          const q = charge * 1e-9; // Convert to Coulombs
          const r = radius * pxToM; // Convert to meters
          const h = height * pxToM; // Convert to meters
          const chargeParamM = chargeParam * pxToM; // Convert charge parameter to meters
          
          // Calculate enclosed charge based on charge type
          let qEnc = 0;
          let chargeDescription = '';
          
          if (chargeType === 'point') {
            qEnc = q;
            chargeDescription = `Point charge: q = ${q.toExponential(2)} C`;
          } else if (chargeType === 'line') {
            // Linear charge density λ = q/L, enclosed charge = λ × length inside sphere
            const lambda = q / (chargeParamM || 1); // Linear charge density (C/m)
            let length = 0;
            if (shape === 'sphere') {
              // For sphere: length of line inside sphere = 2 * sqrt(r² - 0²) = 2r (if line goes through center)
              // But we need to account for the actual line length
              const lineLength = chargeParamM;
              // If sphere radius is larger than half the line length, entire line is inside
              if (r >= lineLength / 2) {
                length = lineLength;
              } else {
                // Only portion of line inside sphere
                length = 2 * r;
              }
            } else {
              // For cylinder: use height of cylinder
              length = h || chargeParamM;
            }
            qEnc = lambda * length;
            chargeDescription = `Line charge: λ = ${lambda.toExponential(2)} C/m, length = ${length.toFixed(3)} m`;
          } else if (chargeType === 'cylinder') {
            // Volume charge density ρ = q/V, enclosed charge = ρ × volume
            const chargeRadius = chargeParamM;
            const rCharge = chargeRadius;
            const volume = Math.PI * rCharge * rCharge * (h || 1);
            const rho = q / (volume || 1);
            // Enclosed charge depends on Gaussian surface shape
            if (shape === 'sphere') {
              // For spherical Gaussian surface: calculate volume of sphere that intersects cylinder
              if (r >= Math.sqrt(rCharge * rCharge + (h || 1) * (h || 1) / 4)) {
                // Sphere completely encloses cylinder
                qEnc = q;
              } else if (r >= rCharge) {
                // Sphere partially encloses cylinder - approximate as volume of sphere
                const sphereVolume = (4/3) * Math.PI * r * r * r;
                // But we need the intersection - approximate as min of sphere volume and cylinder volume
                qEnc = rho * Math.min(sphereVolume, volume);
              } else {
                // Sphere is smaller than cylinder radius - use sphere volume
                const sphereVolume = (4/3) * Math.PI * r * r * r;
                qEnc = rho * sphereVolume;
              }
            } else {
              // For cylindrical Gaussian surface
              if (r >= rCharge) {
                qEnc = q;
              } else {
                const encVolume = Math.PI * r * r * (h || 1);
                qEnc = rho * encVolume;
              }
            }
            chargeDescription = `Cylinder charge: ρ = ${rho.toExponential(2)} C/m³, radius = ${rCharge.toFixed(3)} m`;
          } else if (chargeType === 'ring') {
            // Ring charge: total charge q, enclosed if Gaussian surface encloses ring
            const ringRadius = chargeParamM;
            if (shape === 'sphere') {
              // For sphere: ring is enclosed if sphere radius > ring radius
              if (r >= ringRadius) {
                qEnc = q;
              } else {
                qEnc = 0; // Ring is outside Gaussian surface
              }
            } else {
              // For other shapes
              if (r >= ringRadius) {
                qEnc = q;
              } else {
                qEnc = 0;
              }
            }
            chargeDescription = `Ring charge: q = ${q.toExponential(2)} C, radius = ${ringRadius.toFixed(3)} m`;
          } else if (chargeType === 'plane') {
            // Surface charge density σ = q/A, enclosed charge = σ × area
            const planeArea = chargeParamM * chargeParamM; // Area of charge plane
            const sigma = q / (planeArea || 1); // Surface charge density (C/m²)
            // For plane, enclosed charge depends on Gaussian surface
            if (shape === 'cylinder') {
              const encArea = Math.PI * r * r; // Area of one cylinder end that intersects plane
              qEnc = sigma * encArea;
            } else if (shape === 'sphere') {
              // For sphere intersecting plane: approximate as circular area with radius = sphere radius
              const encArea = Math.PI * r * r;
              qEnc = sigma * encArea;
            } else {
              qEnc = sigma * (Math.PI * r * r);
            }
            chargeDescription = `Plane charge: σ = ${sigma.toExponential(2)} C/m²`;
          }
          
          const flux = qEnc / epsilon0;
          
          let formulaHTML = '';
          
          // Calculate electric field based on charge type and shape
          let E = 0;
          let fieldFormula = '';
          
          if (shape === 'sphere') {
            // For spherical Gaussian surface, use Gauss' Law directly: E = Q_enc / (ε₀ * 4πr²)
            const area = 4 * Math.PI * r * r;
            E = qEnc / (epsilon0 * area);
            fieldFormula = `E = Q_enc/(ε₀·4πr²) = (${qEnc.toExponential(2)} C) / (${epsilon0.toExponential(2)} C²/N⋅m² × ${area.toExponential(2)} m²)`;
          } else if (chargeType === 'point') {
            E = (k * qEnc) / (r * r);
            fieldFormula = `E = kQ_enc/r² = (9×10⁹ N⋅m²/C²) × (${qEnc.toExponential(2)} C) / (${r.toFixed(3)} m)²`;
          } else if (chargeType === 'line') {
            const lambda = q / (chargeParamM || 1);
            E = (2 * k * lambda) / r;
            fieldFormula = `E = 2kλ/r = 2 × (9×10⁹ N⋅m²/C²) × (${lambda.toExponential(2)} C/m) / (${r.toFixed(3)} m)`;
          } else if (chargeType === 'cylinder') {
            const chargeRadius = chargeParamM;
            if (r >= chargeRadius) {
              const lambda = q / (h || 1);
              E = (2 * k * lambda) / r;
              fieldFormula = `E = 2kλ/r = 2 × (9×10⁹ N⋅m²/C²) × (${lambda.toExponential(2)} C/m) / (${r.toFixed(3)} m)`;
            } else {
              const rho = q / (Math.PI * chargeRadius * chargeRadius * (h || 1));
              E = (rho * r) / (2 * epsilon0);
              fieldFormula = `E = ρr/(2ε₀) = (${rho.toExponential(2)} C/m³) × (${r.toFixed(3)} m) / (2 × ${epsilon0.toExponential(2)} C²/N⋅m²)`;
            }
          } else if (chargeType === 'ring') {
            E = (k * qEnc) / (r * r);
            fieldFormula = `E = kQ_enc/r² = (9×10⁹ N⋅m²/C²) × (${qEnc.toExponential(2)} C) / (${r.toFixed(3)} m)²`;
          } else if (chargeType === 'plane') {
            const sigma = q / (chargeParamM * chargeParamM || 1);
            E = sigma / (2 * epsilon0);
            fieldFormula = `E = σ/(2ε₀) = (${sigma.toExponential(2)} C/m²) / (2 × ${epsilon0.toExponential(2)} C²/N⋅m²)`;
            // For plane with cylinder, flux through both ends
            if (shape === 'cylinder') {
              E = sigma / (2 * epsilon0); // Field on each side
            }
          }
          
          if (shape === 'sphere') {
            // For sphere: ∮ E · dA = E(4πr²) = q/ε₀
            const area = 4 * Math.PI * r * r;
            const fluxCalc = E * area;
            
            formulaHTML = `
              <div style="margin-bottom: 0.5rem;"><strong>∮ E · dA = Q_enc/ε₀</strong></div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Charge Distribution:</strong> ${chargeDescription}
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.8rem; padding: 0.5rem; background: ${isDark ? 'rgba(129, 140, 248, 0.1)' : 'rgba(26, 35, 126, 0.05)'}; border-left: 3px solid var(--accent); border-radius: 4px;">
                <strong>Surface Area Formula:</strong> For a <strong>sphere</strong>: A = 4πr²<br>
                <strong>Gauss' Law Applied:</strong> For a <strong>spherical</strong> Gaussian surface:<br>
                E · (4πr²) = Q_enc/ε₀
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 1:</strong> Calculate electric field E<br>
                ${fieldFormula}<br>
                E = ${E.toExponential(2)} N/C
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 2:</strong> Calculate surface area A<br>
                <strong>Surface Area Formula (Sphere):</strong> A = 4πr²<br>
                <div style="margin-left: 0.5rem; margin-top: 0.3rem;">
                  A = 4πr² = 4π × (${r.toFixed(3)} m)²<br>
                  A = 4 × π × ${(r * r).toFixed(6)} m²<br>
                  A = ${area.toExponential(2)} m²
                </div>
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 3:</strong> Calculate flux Φ = E · A<br>
                Φ = (${E.toExponential(2)} N/C) × (${area.toExponential(2)} m²)<br>
                Φ = ${fluxCalc.toExponential(2)} N⋅m²/C
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 4:</strong> Verify Gauss' Law<br>
                Q_enc/ε₀ = (${qEnc.toExponential(2)} C) / (${epsilon0.toExponential(2)} C²/N⋅m²)<br>
                Q_enc/ε₀ = ${flux.toExponential(2)} N⋅m²/C<br>
                <span style="color: ${isDark ? '#4ade80' : '#22c55e'}; font-weight: bold;">✓ Φ = Q_enc/ε₀</span>
              </div>
            `;
          } else if (shape === 'cylinder') {
            // For cylinder: ∮ E · dA = E(2πrh) = q/ε₀ (if charge is inside)
            const sideArea = 2 * Math.PI * r * h;
            let fluxSide = 0;
            let fluxTopBottom = 0;
            let fluxTotal = 0;
            
            if (chargeType === 'plane') {
              // For plane charge: flux only through top and bottom (E ⟂ side)
              const topArea = Math.PI * r * r;
              const sigma = q / (chargeParamM * chargeParamM || 1);
              const E_plane = sigma / (2 * epsilon0);
              fluxTopBottom = E_plane * topArea * 2; // Both top and bottom
              fluxTotal = fluxTopBottom;
            } else {
              // For other charges: flux through side only (E is radial)
              fluxSide = E * sideArea;
              fluxTotal = fluxSide;
            }
            
            formulaHTML = `
              <div style="margin-bottom: 0.5rem;"><strong>∮ E · dA = Q_enc/ε₀</strong></div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Charge Distribution:</strong> ${chargeDescription}
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.8rem; padding: 0.5rem; background: ${isDark ? 'rgba(129, 140, 248, 0.1)' : 'rgba(26, 35, 126, 0.05)'}; border-left: 3px solid var(--accent); border-radius: 4px;">
                <strong>Surface Area Formulas:</strong> For a <strong>cylinder</strong>:<br>
                &nbsp;&nbsp;• Side area: A_side = 2πrh<br>
                &nbsp;&nbsp;• Top/Bottom area: A_top = A_bottom = πr²<br>
                <strong>Gauss' Law Applied:</strong> For a <strong>cylindrical</strong> Gaussian surface:<br>
                ${chargeType === 'plane' ? 'E · (2πr²) = Q_enc/ε₀ (flux through top/bottom only, side has E ⟂ dA)' : 'E · (2πrh) = Q_enc/ε₀ (flux through side only, top/bottom have E ⟂ dA)'}
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 1:</strong> Calculate electric field E${chargeType === 'plane' ? ' (perpendicular to plane)' : ' (radial)'}<br>
                ${fieldFormula}<br>
                E = ${chargeType === 'plane' ? (q / (chargeParamM * chargeParamM || 1) / (2 * epsilon0)).toExponential(2) : E.toExponential(2)} N/C
              </div>
              ${chargeType === 'plane' ? `
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 2:</strong> Calculate top/bottom surface area A<br>
                <strong>Surface Area Formula (Cylinder Top/Bottom):</strong> A_top = A_bottom = πr²<br>
                <div style="margin-left: 0.5rem; margin-top: 0.3rem;">
                  A_total = 2 × πr² = 2 × π × (${r.toFixed(3)} m)²<br>
                  A_total = 2 × π × ${(r * r).toFixed(6)} m²<br>
                  A_total = ${(2 * Math.PI * r * r).toExponential(2)} m²<br>
                  <small>(Sum of top and bottom circular faces)</small>
                </div>
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 3:</strong> Calculate flux Φ = E · A<br>
                Φ = (${(q / (chargeParamM * chargeParamM || 1) / (2 * epsilon0)).toExponential(2)} N/C) × (${(2 * Math.PI * r * r).toExponential(2)} m²)<br>
                Φ = ${fluxTotal.toExponential(2)} N⋅m²/C<br>
                <small>(Flux through side = 0, since E ⟂ dA)</small>
              </div>
              ` : `
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 2:</strong> Calculate side surface area A_side<br>
                <strong>Surface Area Formula (Cylinder Side):</strong> A_side = 2πrh<br>
                <div style="margin-left: 0.5rem; margin-top: 0.3rem;">
                  A_side = 2πrh = 2π × (${r.toFixed(3)} m) × (${h.toFixed(3)} m)<br>
                  A_side = 2 × π × ${r.toFixed(3)} × ${h.toFixed(3)} m²<br>
                  A_side = ${sideArea.toExponential(2)} m²<br>
                  <small>(Lateral surface area: circumference × height)</small>
                </div>
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 3:</strong> Calculate flux Φ = E · A_side<br>
                Φ = (${E.toExponential(2)} N/C) × (${sideArea.toExponential(2)} m²)<br>
                Φ = ${fluxTotal.toExponential(2)} N⋅m²/C<br>
                <small>(Flux through top/bottom = 0, since E ⟂ dA)</small>
              </div>
              `}
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step ${chargeType === 'plane' ? '4' : '4'}:</strong> Verify Gauss' Law<br>
                Q_enc/ε₀ = (${qEnc.toExponential(2)} C) / (${epsilon0.toExponential(2)} C²/N⋅m²)<br>
                Q_enc/ε₀ = ${flux.toExponential(2)} N⋅m²/C<br>
                <span style="color: ${isDark ? '#4ade80' : '#22c55e'}; font-weight: bold;">✓ Φ = Q_enc/ε₀</span>
              </div>
            `;
          } else if (shape === 'ring') {
            // For ring (torus): Surface area = 4π²Rr where R is major radius, r is minor radius
            // For simplicity, we use the same radius for both (R = r)
            // Torus surface area: A = 4π²Rr, where R = r (major radius = minor radius)
            const ringArea = 4 * Math.PI * Math.PI * r * r;
            const fluxRing = E * ringArea;
            
            formulaHTML = `
              <div style="margin-bottom: 0.5rem;"><strong>∮ E · dA = Q_enc/ε₀</strong></div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Charge Distribution:</strong> ${chargeDescription}
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.8rem; padding: 0.5rem; background: ${isDark ? 'rgba(129, 140, 248, 0.1)' : 'rgba(26, 35, 126, 0.05)'}; border-left: 3px solid var(--accent); border-radius: 4px;">
                <strong>Surface Area Formula:</strong> For a <strong>torus</strong> (ring): A = 4π²Rr<br>
                &nbsp;&nbsp;where R = major radius, r = minor radius (here R = r)<br>
                <strong>Gauss' Law Applied:</strong> For a <strong>ring</strong> (torus) Gaussian surface:<br>
                E · A_ring = Q_enc/ε₀
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 1:</strong> Calculate electric field E<br>
                ${fieldFormula}<br>
                E = ${E.toExponential(2)} N/C
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 2:</strong> Calculate ring (torus) surface area A<br>
                <strong>Surface Area Formula (Torus):</strong> A = 4π²Rr<br>
                <div style="margin-left: 0.5rem; margin-top: 0.3rem;">
                  Where R = major radius, r = minor radius (here R = r = ${r.toFixed(3)} m)<br>
                  A = 4π²Rr = 4π² × (${r.toFixed(3)} m) × (${r.toFixed(3)} m)<br>
                  A = 4 × π² × ${(r * r).toFixed(6)} m²<br>
                  A = ${ringArea.toExponential(2)} m²<br>
                  <small>(Surface area of a torus/donut shape)</small>
                </div>
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 3:</strong> Calculate flux Φ = E · A<br>
                Φ = (${E.toExponential(2)} N/C) × (${ringArea.toExponential(2)} m²)<br>
                Φ = ${fluxRing.toExponential(2)} N⋅m²/C
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 4:</strong> Verify Gauss' Law<br>
                Q_enc/ε₀ = (${qEnc.toExponential(2)} C) / (${epsilon0.toExponential(2)} C²/N⋅m²)<br>
                Q_enc/ε₀ = ${flux.toExponential(2)} N⋅m²/C<br>
                <span style="color: ${isDark ? '#4ade80' : '#22c55e'}; font-weight: bold;">✓ Φ = Q_enc/ε₀</span>
              </div>
            `;
          }
          
          document.getElementById('gauss-formula-content').innerHTML = formulaHTML;
        }
        
        function drawGauss() {
          const isDark = document.body.classList.contains('dark');
          ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          const chargeType = document.getElementById('gauss-charge-type').value;
          const charge = parseFloat(document.getElementById('gauss-charge').value);
          const chargeParam = document.getElementById('gauss-charge-param') ? parseFloat(document.getElementById('gauss-charge-param').value) : 0;
          const shape = document.getElementById('gauss-shape').value;
          const radius = parseFloat(document.getElementById('gauss-radius').value);
          const height = document.getElementById('gauss-height') ? parseFloat(document.getElementById('gauss-height').value) : 200;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          
          // Draw charge distribution first (behind Gaussian surface)
          ctx.fillStyle = charge > 0 ? (isDark ? 'rgba(252, 165, 165, 0.4)' : 'rgba(229, 57, 53, 0.4)') : (isDark ? 'rgba(147, 197, 253, 0.4)' : 'rgba(25, 118, 210, 0.4)');
          ctx.strokeStyle = charge > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
          ctx.lineWidth = 2;
          
          if (chargeType === 'point') {
            const chargeRadius = Math.abs(charge) * 3 + 8;
            ctx.beginPath();
            ctx.arc(centerX, centerY, chargeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(charge > 0 ? '+' : '-', centerX, centerY + 5);
          } else if (chargeType === 'line') {
            // Draw vertical line of charge
            const lineLength = chargeParam || height;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - lineLength / 2);
            ctx.lineTo(centerX, centerY + lineLength / 2);
            ctx.lineWidth = 4;
            ctx.stroke();
            // Draw charge symbols along the line
            ctx.fillStyle = charge > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            for (let i = -2; i <= 2; i++) {
              const y = centerY + (i * lineLength / 5);
              ctx.beginPath();
              ctx.arc(centerX, y, 6, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (chargeType === 'cylinder') {
            // Draw cylinder of charge
            const chargeRadius = chargeParam || 50;
            const topY = centerY - height / 2;
            const bottomY = centerY + height / 2;
            // Draw filled cylinder
            ctx.fillRect(centerX - chargeRadius, topY, chargeRadius * 2, height);
            ctx.strokeRect(centerX - chargeRadius, topY, chargeRadius * 2, height);
            // Draw top and bottom circles
            ctx.beginPath();
            ctx.ellipse(centerX, topY, chargeRadius, chargeRadius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(centerX, bottomY, chargeRadius, chargeRadius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          } else if (chargeType === 'ring') {
            // Draw ring of charge
            const ringRadius = chargeParam || 100;
            ctx.beginPath();
            ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
            ctx.lineWidth = 8;
            ctx.stroke();
            // Draw charge symbols around the ring
            ctx.fillStyle = charge > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            for (let i = 0; i < 8; i++) {
              const angle = (i * Math.PI * 2) / 8;
              const x = centerX + Math.cos(angle) * ringRadius;
              const y = centerY + Math.sin(angle) * ringRadius;
              ctx.beginPath();
              ctx.arc(x, y, 6, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (chargeType === 'plane') {
            // Draw plane of charge (horizontal line)
            const planeWidth = chargeParam || 400;
            ctx.beginPath();
            ctx.moveTo(centerX - planeWidth / 2, centerY);
            ctx.lineTo(centerX + planeWidth / 2, centerY);
            ctx.lineWidth = 6;
            ctx.stroke();
            // Draw charge symbols along the plane
            ctx.fillStyle = charge > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            for (let i = -4; i <= 4; i++) {
              const x = centerX + (i * planeWidth / 9);
              ctx.beginPath();
              ctx.arc(x, centerY, 6, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          // Draw Gaussian surface
          ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.8)' : 'rgba(26, 35, 126, 0.8)';
          ctx.lineWidth = 3;
          ctx.setLineDash([10, 5]);
          
          if (shape === 'sphere') {
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
          } else if (shape === 'cylinder') {
            // Draw cylinder (side view as rectangle with ellipses on top/bottom)
            const topY = centerY - height / 2;
            const bottomY = centerY + height / 2;
            
            // Draw side lines
            ctx.beginPath();
            ctx.moveTo(centerX - radius, topY);
            ctx.lineTo(centerX - radius, bottomY);
            ctx.moveTo(centerX + radius, topY);
            ctx.lineTo(centerX + radius, bottomY);
            ctx.stroke();
            
            // Draw top ellipse
            ctx.beginPath();
            ctx.ellipse(centerX, topY, radius, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw bottom ellipse
            ctx.beginPath();
            ctx.ellipse(centerX, bottomY, radius, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();
          } else if (shape === 'ring') {
            // Draw ring (torus) - side view as two circles
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw inner circle to show it's a ring
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw connecting lines to show it's a torus
            ctx.beginPath();
            ctx.moveTo(centerX - radius, centerY);
            ctx.lineTo(centerX - radius * 0.6, centerY);
            ctx.moveTo(centerX + radius, centerY);
            ctx.lineTo(centerX + radius * 0.6, centerY);
            ctx.stroke();
          }
          
          ctx.setLineDash([]);
          
          // Update formula display
          updateFormulaDisplay();
        }
        
        // Store draw function globally for theme changes
        gaussDrawFunction = drawGauss;
        
        // Only set up event listeners once
        if (!gaussCanvasInitialized) {
          gaussCanvasInitialized = true;
          
          // Charge type selector handler
          document.getElementById('gauss-charge-type').addEventListener('change', (e) => {
          const chargeType = e.target.value;
          const chargeLabel = document.getElementById('gauss-charge-label');
          const chargeUnit = document.getElementById('gauss-charge-unit');
          const chargeParamGroup = document.getElementById('gauss-charge-param-group');
          const chargeParamLabel = document.getElementById('gauss-charge-param-label');
          const chargeParamUnit = document.getElementById('gauss-charge-param-unit');
          const chargeInput = document.getElementById('gauss-charge');
          
          if (chargeType === 'point') {
            chargeLabel.textContent = 'Point Charge (q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'none';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          } else if (chargeType === 'line') {
            chargeLabel.textContent = 'Total Charge (Q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'flex';
            chargeParamLabel.textContent = 'Line Length (L):';
            chargeParamUnit.textContent = 'px';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          } else if (chargeType === 'cylinder') {
            chargeLabel.textContent = 'Total Charge (Q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'flex';
            chargeParamLabel.textContent = 'Cylinder Radius (R):';
            chargeParamUnit.textContent = 'px';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          } else if (chargeType === 'ring') {
            chargeLabel.textContent = 'Total Charge (Q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'flex';
            chargeParamLabel.textContent = 'Ring Radius (R):';
            chargeParamUnit.textContent = 'px';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          } else if (chargeType === 'plane') {
            chargeLabel.textContent = 'Total Charge (Q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'flex';
            chargeParamLabel.textContent = 'Plane Width (W):';
            chargeParamUnit.textContent = 'px';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          }
          drawGauss();
          });
          
          // Shape selector handler
          document.getElementById('gauss-shape').addEventListener('change', (e) => {
          const shape = e.target.value;
          const heightGroup = document.getElementById('gauss-height-group');
          const sizeLabel = document.getElementById('gauss-size-label');
          
          if (shape === 'cylinder') {
            heightGroup.style.display = 'flex';
            sizeLabel.textContent = 'Radius (r):';
          } else if (shape === 'ring') {
            heightGroup.style.display = 'none';
            sizeLabel.textContent = 'Radius (r):';
          } else {
            heightGroup.style.display = 'none';
            sizeLabel.textContent = 'Radius (r):';
          }
          drawGauss();
          });
          
          // Toggle calculation display button
          const toggleButton = document.getElementById('gauss-toggle-calculation');
          const formulaDisplay = document.getElementById('gauss-formula-display');
          toggleButton.addEventListener('click', () => {
          const isVisible = formulaDisplay.style.display !== 'none';
          if (isVisible) {
            formulaDisplay.style.display = 'none';
            toggleButton.textContent = 'Show Calculation';
          } else {
            formulaDisplay.style.display = 'block';
            toggleButton.textContent = 'Hide Calculation';
            // Update formula display when showing
            updateFormulaDisplay();
          }
          });
          
          document.getElementById('gauss-charge').addEventListener('input', (e) => {
            document.getElementById('gauss-charge-value').textContent = e.target.value;
            drawGauss();
          });
          const chargeParamInput = document.getElementById('gauss-charge-param');
          if (chargeParamInput) {
            chargeParamInput.addEventListener('input', (e) => {
              document.getElementById('gauss-charge-param-value').textContent = e.target.value;
              drawGauss();
            });
          }
          document.getElementById('gauss-radius').addEventListener('input', (e) => {
            document.getElementById('gauss-radius-value').textContent = e.target.value;
            drawGauss();
          });
          const heightInput = document.getElementById('gauss-height');
          if (heightInput) {
            heightInput.addEventListener('input', (e) => {
              document.getElementById('gauss-height-value').textContent = e.target.value;
              drawGauss();
            });
          }
        }
        
        // Always redraw when initialized
        drawGauss();
      }
    });
  </script>
</body>
</html>

