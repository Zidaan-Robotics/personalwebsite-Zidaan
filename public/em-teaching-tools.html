<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>E&M Teaching Tools - Zidaan</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --bg-start: #e3f2fd;
      --bg-end: #f3e5f5;
      --text: rgba(0,0,0,0.87);
      --panel-bg: #ffffff;
      --panel-border: rgba(0,0,0,.06);
      --btn-start: #1e88e5;
      --btn-end: #3949ab;
      --accent: #1a237e;
      --subtle: rgba(0,0,0,.65);
    }
    body.dark {
      --bg-start: #000000;
      --bg-end: #0a0a0a;
      --text: rgba(255,255,255,0.98);
      --panel-bg: #050505;
      --panel-border: rgba(255,255,255,.2);
      --btn-start: #818cf8;
      --btn-end: #4f46e5;
      --accent: #c7d2fe;
      --subtle: rgba(255,255,255,.85);
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
      min-height: 100vh;
      padding: 2rem;
      color: var(--text);
    }
    .header {
      position: fixed;
      top: 0;
      right: 0;
      padding: 1rem;
      z-index: 10;
    }
    .toggle {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .toggle span {
      font-size: 14px;
      color: var(--subtle);
    }
    .switch {
      position: relative;
      width: 46px;
      height: 26px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #cfd8dc;
      transition: .2s;
      border-radius: 999px;
    }
    .slider:before {
      content: "";
      position: absolute;
      height: 20px;
      width: 20px;
      left: 3px;
      top: 3px;
      background: #fff;
      transition: .2s;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,.3);
    }
    input:checked + .slider {
      background: #37474f;
    }
    input:checked + .slider:before {
      transform: translateX(20px);
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 20px;
      padding: 3rem;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    h1 {
      color: var(--accent);
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }
    .content {
      line-height: 1.8;
      font-size: 1.1rem;
      color: var(--subtle);
      margin-bottom: 2rem;
    }
    .back-button {
      display: inline-block;
      padding: 0.75rem 2rem;
      font-size: 1rem;
      font-weight: 600;
      color: white;
      background: linear-gradient(135deg, var(--btn-start), var(--btn-end));
      border: none;
      border-radius: 50px;
      cursor: pointer;
      text-decoration: none;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .back-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    .back-button:active {
      transform: translateY(0);
    }
    .tools-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
      margin: 2rem 0;
    }
    .tool-card {
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 1.5rem;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .tool-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    .tool-card h3 {
      color: var(--accent);
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }
    .tool-card p {
      color: var(--subtle);
      font-size: 0.9rem;
      line-height: 1.5;
    }
    .tool-section {
      display: none;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 20px;
      padding: 2rem;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      margin: 2rem 0;
    }
    .tool-section.active {
      display: block;
    }
    .tool-section h2 {
      color: var(--accent);
      margin-bottom: 1rem;
    }
    .tool-section p {
      color: var(--subtle);
      margin-bottom: 1.5rem;
      line-height: 1.6;
    }
    .canvas-container {
      background: #fff;
      border: 2px solid var(--panel-border);
      border-radius: 12px;
      margin: 1rem 0;
      position: relative;
      overflow: hidden;
    }
    body.dark .canvas-container {
      background: #1a1a1a;
    }
    canvas {
      display: block;
      cursor: crosshair;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin: 1rem 0;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .control-group label {
      font-size: 0.9rem;
      color: var(--subtle);
    }
    .control-group input[type="number"],
    .control-group input[type="range"],
    .control-group select {
      padding: 0.5rem;
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      background: var(--panel-bg);
      color: var(--text);
      font-size: 0.9rem;
    }
    .control-group input[type="range"] {
      width: 150px;
    }
    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      color: white;
      background: linear-gradient(135deg, var(--btn-start), var(--btn-end));
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    button:active {
      transform: translateY(0);
    }
    .info-box {
      background: rgba(26, 35, 126, 0.1);
      border-left: 4px solid var(--accent);
      padding: 1rem;
      border-radius: 6px;
      margin: 1rem 0;
      font-size: 0.9rem;
      color: var(--subtle);
    }
    body.dark .info-box {
      background: rgba(199, 210, 254, 0.1);
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="toggle">
      <span>Dark Mode</span>
      <label class="switch">
        <input id="theme-toggle" type="checkbox" aria-label="Toggle dark mode">
        <span class="slider"></span>
      </label>
    </div>
  </div>
  <div class="container">
    <h1>E&M Teaching Tools</h1>
    <div class="tools-grid" id="tools-grid">
      <div class="tool-card" data-tool="electric-field">
        <h3>Electric Field</h3>
        <p>Visualize electric field lines around charges. Supports point, line, ring, and surface charges. Click to place charges.</p>
      </div>
      <div class="tool-card" data-tool="flux">
        <h3>Electric Flux</h3>
        <p>Explore how electric flux depends on field strength and surface orientation.</p>
      </div>
      <div class="tool-card" data-tool="voltage">
        <h3>Voltage & Equipotentials</h3>
        <p>See equipotential lines and understand voltage relationships.</p>
      </div>
      <div class="tool-card" data-tool="gauss">
        <h3>Gauss' Law</h3>
        <p>Discover how flux through a closed surface relates to enclosed charge.</p>
      </div>
    </div>

    <!-- Electric Field Tool Section -->
    <div class="tool-section" id="electric-field-section">
      <h2>Electric Field Visualization</h2>
      <p>Click on the canvas to place charges. Positive charges repel, negative charges attract. The field lines show the direction and strength of the electric field.</p>
      <div class="info-box">
        <strong>Formula:</strong> E = kq/r² where k = 9×10⁹ N⋅m²/C², q is charge, r is distance
      </div>
      <div class="controls">
        <div class="control-group">
          <label>Charge Type:</label>
          <select id="charge-type">
            <option value="positive">Positive (+)</option>
            <option value="negative">Negative (-)</option>
          </select>
        </div>
        <div class="control-group">
          <label>Charge Magnitude:</label>
          <input type="range" id="charge-magnitude" min="1" max="10" value="5" step="0.5">
          <span id="magnitude-value">5</span>
        </div>
        <button id="clear-field">Clear All</button>
      </div>
      <div class="canvas-container">
        <canvas id="field-canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <!-- Flux Tool Section -->
    <div class="tool-section" id="flux-section">
      <h2>Electric Flux</h2>
      <p>Electric flux is the measure of electric field passing through a surface. Rotate the surface and see how the flux changes with angle.</p>
      <div class="info-box">
        <strong>Formula:</strong> Φ = E⋅A⋅cos(θ) where E is electric field, A is area, θ is angle between field and normal
      </div>
      <div class="controls">
        <div class="control-group">
          <label>View Mode:</label>
          <select id="flux-view-mode">
            <option value="2d">2D View</option>
            <option value="3d">3D View</option>
          </select>
        </div>
        <div class="control-group">
          <label>Shape Type:</label>
          <select id="flux-shape-type">
            <option value="rectangle">Rectangle</option>
            <option value="circle">Circle</option>
            <option value="triangle">Triangle</option>
            <option value="draw">Draw Custom Shape</option>
          </select>
        </div>
        <div class="control-group">
          <label>Field Type:</label>
          <select id="flux-field-type">
            <option value="uniform-vertical">Uniform Vertical</option>
            <option value="uniform-diagonal">Uniform Diagonal</option>
            <option value="nonuniform-radial">Nonuniform (Radial)</option>
            <option value="nonuniform-varying">Nonuniform (Varying Strength)</option>
          </select>
        </div>
        <div class="control-group" id="flux-field-strength-group">
          <label>Field Strength (N/C):</label>
          <input type="range" id="flux-field-strength" min="1" max="20" value="10" step="0.5">
          <span id="flux-field-value">10</span>
        </div>
        <div class="control-group" id="flux-field-angle-group" style="display: none;">
          <label>Field Angle (degrees):</label>
          <input type="range" id="flux-field-angle" min="0" max="360" value="90" step="5">
          <span id="flux-field-angle-value">90</span>°
        </div>
        <div class="control-group" id="flux-angle-group">
          <label>Surface Angle (degrees):</label>
          <input type="range" id="flux-angle" min="0" max="180" value="0" step="5">
          <span id="flux-angle-value">0</span>
        </div>
        <div class="control-group" id="flux-3d-controls" style="display: none;">
          <label>Rotation X (pitch):</label>
          <input type="range" id="flux-rotation-x" min="-90" max="90" value="0" step="5">
          <span id="flux-rotation-x-value">0</span>°
        </div>
        <div class="control-group" id="flux-3d-controls-y" style="display: none;">
          <label>Rotation Y (yaw):</label>
          <input type="range" id="flux-rotation-y" min="-180" max="180" value="0" step="5">
          <span id="flux-rotation-y-value">0</span>°
        </div>
        <button id="clear-flux-shape">Clear Shape</button>
      </div>
      <div class="info-box" id="flux-display" style="margin-top: 1rem; font-size: 1.1rem;">
        <strong>Electric Flux (Φ):</strong> <span id="flux-value">0.00</span> N⋅m²/C
      </div>
      <div class="canvas-container">
        <canvas id="flux-canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <!-- Voltage Tool Section -->
    <div class="tool-section" id="voltage-section">
      <h2>Voltage & Equipotential Lines</h2>
      <p>Equipotential lines connect points of equal voltage. They are always perpendicular to electric field lines.</p>
      <div class="info-box">
        <strong>Formula:</strong> V = kq/r where V is voltage, k = 9×10⁹ N⋅m²/C², q is charge, r is distance
      </div>
      <div class="controls">
        <div class="control-group">
          <label>Charge Type:</label>
          <select id="voltage-charge-type">
            <option value="positive">Positive (+)</option>
            <option value="negative">Negative (-)</option>
          </select>
        </div>
        <div class="control-group">
          <label>Charge Magnitude:</label>
          <input type="range" id="voltage-charge-magnitude" min="1" max="10" value="5" step="0.5">
          <span id="voltage-magnitude-value">5</span>
        </div>
        <div class="control-group" style="flex-shrink: 0;">
          <button id="show-field-lines">Show E</button>
          <button id="clear-voltage">Clear All</button>
        </div>
      </div>
      <div class="canvas-container">
        <canvas id="voltage-canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <!-- Gauss' Law Tool Section -->
    <div class="tool-section" id="gauss-section">
      <h2>Gauss' Law</h2>
      <p>Gauss' law states that the electric flux through a closed surface is proportional to the charge enclosed.</p>
      <div class="info-box">
        <strong>Gauss' Law:</strong> ∮ E · dA = Q_enc/ε₀ where Q_enc is enclosed charge, ε₀ = 8.85×10⁻¹² C²/N⋅m²
      </div>
      <div class="controls">
        <div class="control-group">
          <label>Charge Distribution Type:</label>
          <select id="gauss-charge-type">
            <option value="point">Point Charge</option>
            <option value="line">Line of Charge</option>
            <option value="cylinder">Cylinder of Charge</option>
            <option value="ring">Ring of Charge</option>
            <option value="plane">Plane of Charge</option>
          </select>
        </div>
        <div class="control-group" id="gauss-charge-group">
          <label id="gauss-charge-label">Point Charge (q):</label>
          <input type="range" id="gauss-charge" min="-10" max="10" value="5" step="0.5">
          <span id="gauss-charge-value">5</span> <span id="gauss-charge-unit">× 10⁻⁹ C</span>
        </div>
        <div class="control-group" id="gauss-charge-param-group" style="display: none;">
          <label id="gauss-charge-param-label"></label>
          <input type="range" id="gauss-charge-param" min="50" max="300" value="100" step="10">
          <span id="gauss-charge-param-value">100</span> <span id="gauss-charge-param-unit">px</span>
        </div>
        <div class="control-group">
          <label>Gaussian Surface Shape:</label>
          <select id="gauss-shape">
            <option value="sphere">Sphere</option>
            <option value="cylinder">Cylinder</option>
            <option value="ring">Ring</option>
          </select>
        </div>
        <div class="control-group">
          <label id="gauss-size-label">Radius (r):</label>
          <input type="range" id="gauss-radius" min="50" max="300" value="150" step="10">
          <span id="gauss-radius-value">150</span> px
        </div>
        <div class="control-group" id="gauss-height-group" style="display: none;">
          <label>Height (h):</label>
          <input type="range" id="gauss-height" min="100" max="400" value="200" step="10">
          <span id="gauss-height-value">200</span> px
        </div>
        <div class="control-group">
          <button id="gauss-toggle-calculation" style="margin-top: 0.5rem;">Show Calculation</button>
        </div>
      </div>
      <div class="formula-display" id="gauss-formula-display" style="background: var(--panel-bg); border: 1px solid var(--panel-border); border-radius: 12px; padding: 1.5rem; margin: 1rem 0; font-family: 'Courier New', monospace; display: none;">
        <div style="font-size: 1.1rem; color: var(--accent); margin-bottom: 0.5rem; font-weight: bold;">Gauss' Law Evaluation:</div>
        <div id="gauss-formula-content" style="color: var(--subtle); line-height: 1.8; font-size: 1rem;"></div>
      </div>
      <div class="canvas-container">
        <canvas id="gauss-canvas" width="800" height="600"></canvas>
      </div>
    </div>

    <a href="index.html" class="back-button">Back to Home</a>
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const themeToggle = document.getElementById('theme-toggle');
      const savedTheme = localStorage.getItem('theme') || 'light';
      if (savedTheme === 'dark') {
        document.body.classList.add('dark');
        themeToggle.checked = true;
      }
      themeToggle.addEventListener('change', () => {
        if (themeToggle.checked) {
          document.body.classList.add('dark');
          localStorage.setItem('theme', 'dark');
        } else {
          document.body.classList.remove('dark');
          localStorage.setItem('theme', 'light');
        }
      });

      // Tool navigation - only show one section at a time
      window.currentTool = null;
      const toolCards = document.querySelectorAll('.tool-card');
      const toolSections = document.querySelectorAll('.tool-section');

      // Ensure all sections are hidden initially
      toolSections.forEach(section => {
        section.classList.remove('active');
      });

      toolCards.forEach(card => {
        card.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const tool = card.dataset.tool;
          if (!tool) {
            console.error('Tool card missing data-tool attribute!');
            return;
          }
          
          // Reset all cards opacity
          toolCards.forEach(c => {
            if (c) c.style.opacity = '1';
          });
          
          // Hide ALL sections first
          toolSections.forEach(s => {
            s.classList.remove('active');
          });
          
          // Show selected card and section
          card.style.opacity = '0.7';
          const targetSection = document.getElementById(`${tool}-section`);
          if (targetSection) {
            targetSection.classList.add('active');
            window.currentTool = tool;
            
            // Initialize tool if function exists
            if (tool === 'electric-field') {
              if (typeof initElectricField === 'function') {
                initElectricField();
              }
              // Redraw if already initialized
              if (fieldCanvasInitialized && typeof window.redrawElectricField === 'function') {
                window.redrawElectricField();
              }
            } else if (tool === 'flux' && typeof initFlux === 'function') {
              initFlux();
            } else if (tool === 'voltage' && typeof initVoltage === 'function') {
              initVoltage();
            } else if (tool === 'gauss' && typeof initGauss === 'function') {
              initGauss();
            }
            
            // Scroll to section smoothly
            setTimeout(() => {
              targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          } else {
            console.error(`Section not found: ${tool}-section`);
          }
        });
      });

      // Basic initialization functions for tools
      let fieldCanvasInitialized = false;
      let charges = [];
      let mouseX = 0;
      let mouseY = 0;
      
      function initElectricField() {
        const canvas = document.getElementById('field-canvas');
        if (!canvas || fieldCanvasInitialized) return;
        fieldCanvasInitialized = true;
        
        const ctx = canvas.getContext('2d');
        const isDark = document.body.classList.contains('dark');
        
        // Constants
        const k = 9e9; // Coulomb's constant (scaled for visualization)
        const fieldLineSpacing = 30; // Spacing between field lines
        const minFieldStrength = 0.1; // Minimum field strength to draw
        
        // Calculate electric field at a point
        function calculateField(x, y) {
          let Ex = 0, Ey = 0;
          for (const charge of charges) {
            const dx = x - charge.x;
            const dy = y - charge.y;
            const r2 = dx * dx + dy * dy;
            if (r2 < 1) continue; // Avoid division by zero
            
            const r = Math.sqrt(r2);
            const magnitude = (k * charge.q) / (r2 * 1e6); // Scale down for visualization
            Ex += magnitude * (dx / r);
            Ey += magnitude * (dy / r);
          }
          return { Ex, Ey, magnitude: Math.sqrt(Ex * Ex + Ey * Ey) };
        }
        
        // Draw a single field line
        function drawFieldLine(startX, startY, direction, chargeSign) {
          const steps = 500;
          const stepSize = 2;
          let x = startX;
          let y = startY;
          const path = [{x, y}];
          
          for (let i = 0; i < steps; i++) {
            const field = calculateField(x, y);
            if (field.magnitude < minFieldStrength) break;
            
            // Normalize field direction
            const len = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
            if (len < 0.01) break;
            
            // For negative charges, field points inward, so we trace in the direction of the field
            // For positive charges, field points outward, so we also trace in the direction of the field
            const dx = (field.Ex / len) * stepSize * direction;
            const dy = (field.Ey / len) * stepSize * direction;
            
            x += dx;
            y += dy;
            
            // Check bounds
            if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) break;
            
            // Check if too close to any charge (for negative charges, we want to reach the charge)
            let tooClose = false;
            for (const charge of charges) {
              const dist = Math.sqrt((x - charge.x) ** 2 + (y - charge.y) ** 2);
              if (dist < 15) {
                tooClose = true;
                break;
              }
            }
            if (tooClose) break;
            
            path.push({x, y});
          }
          
          // Draw the field line
          if (path.length > 1) {
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
              ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
          }
        }
        
        // Draw all field lines
        function drawFieldLines() {
          if (charges.length === 0) return;
          
          ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.4)' : 'rgba(26, 35, 126, 0.4)';
          ctx.lineWidth = 1.5;
          
          // Draw field lines from each charge
          for (const charge of charges) {
            const numLines = Math.max(8, Math.floor(Math.abs(charge.q) * 2));
            const angleStep = (2 * Math.PI) / numLines;
            
            if (charge.q > 0) {
              // Positive charges: start near charge, trace outward
              for (let i = 0; i < numLines; i++) {
                const angle = i * angleStep;
                const startRadius = 20 + Math.abs(charge.q) * 3;
                const startX = charge.x + Math.cos(angle) * startRadius;
                const startY = charge.y + Math.sin(angle) * startRadius;
                drawFieldLine(startX, startY, 1, 1);
              }
            } else {
              // Negative charges: start far from charge, trace inward toward the charge
              for (let i = 0; i < numLines; i++) {
                const angle = i * angleStep;
                // Start from multiple distances to ensure good coverage
                const distances = [
                  Math.min(canvas.width, canvas.height) * 0.45,
                  Math.min(canvas.width, canvas.height) * 0.35,
                  Math.min(canvas.width, canvas.height) * 0.25
                ];
                
                for (const maxDist of distances) {
                  const startX = charge.x + Math.cos(angle) * maxDist;
                  const startY = charge.y + Math.sin(angle) * maxDist;
                  
                  // Make sure start point is within canvas
                  if (startX >= 10 && startX <= canvas.width - 10 && 
                      startY >= 10 && startY <= canvas.height - 10) {
                    drawFieldLine(startX, startY, 1, -1);
                    break; // Only draw one line per angle
                  }
                }
              }
            }
          }
        }
        
        // Main draw function
        function draw() {
          // Clear canvas
          ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw charges first (background layer)
          for (const charge of charges) {
            const radius = 10 + Math.abs(charge.q) * 2;
            ctx.beginPath();
            ctx.arc(charge.x, charge.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = charge.q > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            ctx.fill();
            ctx.strokeStyle = isDark ? '#fff' : '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(charge.q > 0 ? '+' : '-', charge.x, charge.y + 5);
          }
          
          // Draw field lines on top of charges
          drawFieldLines();
          
          // Draw electric field at mouse position (on top of everything)
          if (mouseX >= 0 && mouseY >= 0 && mouseX <= canvas.width && mouseY <= canvas.height) {
            const field = calculateField(mouseX, mouseY);
            if (field.magnitude > 0.01) {
              // Draw field vector
              const scale = 50; // Scale factor for visualization
              const arrowLength = Math.min(field.magnitude * scale, 100);
              const angle = Math.atan2(field.Ey, field.Ex);
              
              ctx.strokeStyle = isDark ? '#fbbf24' : '#f59e0b';
              ctx.fillStyle = isDark ? '#fbbf24' : '#f59e0b';
              ctx.lineWidth = 2;
              
              // Draw arrow
              ctx.beginPath();
              ctx.moveTo(mouseX, mouseY);
              ctx.lineTo(
                mouseX + arrowLength * Math.cos(angle),
                mouseY + arrowLength * Math.sin(angle)
              );
              ctx.stroke();
              
              // Draw arrowhead
              const arrowSize = 8;
              ctx.beginPath();
              ctx.moveTo(
                mouseX + arrowLength * Math.cos(angle),
                mouseY + arrowLength * Math.sin(angle)
              );
              ctx.lineTo(
                mouseX + arrowLength * Math.cos(angle) - arrowSize * Math.cos(angle - Math.PI / 6),
                mouseY + arrowLength * Math.sin(angle) - arrowSize * Math.sin(angle - Math.PI / 6)
              );
              ctx.lineTo(
                mouseX + arrowLength * Math.cos(angle) - arrowSize * Math.cos(angle + Math.PI / 6),
                mouseY + arrowLength * Math.sin(angle) - arrowSize * Math.sin(angle + Math.PI / 6)
              );
              ctx.closePath();
              ctx.fill();
              
              // Draw magnitude text - ensure it stays within canvas bounds
              ctx.fillStyle = isDark ? '#fbbf24' : '#f59e0b';
              ctx.font = '12px Arial';
              const magnitudeText = `E = ${field.magnitude.toFixed(2)} N/C`;
              const textWidth = ctx.measureText(magnitudeText).width;
              const textHeight = 20;
              const padding = 5;
              
              // Calculate text position (prefer to the right and below arrow)
              let textX = mouseX + arrowLength * Math.cos(angle) + 10;
              let textY = mouseY + arrowLength * Math.sin(angle) + 5;
              
              // Adjust if text would go outside right edge
              if (textX + textWidth + padding > canvas.width) {
                textX = mouseX - textWidth - padding - 10;
              }
              
              // Adjust if text would go outside left edge
              if (textX < padding) {
                textX = padding;
              }
              
              // Adjust if text would go outside bottom edge
              if (textY + textHeight > canvas.height) {
                textY = mouseY - arrowLength * Math.sin(angle) - textHeight - 5;
              }
              
              // Adjust if text would go outside top edge
              if (textY < textHeight) {
                textY = textHeight;
              }
              
              // Draw text background
              ctx.fillRect(textX - padding, textY - textHeight + padding, textWidth + padding * 2, textHeight);
              
              // Draw text
              ctx.textAlign = 'left';
              ctx.fillStyle = isDark ? '#000' : '#fff';
              ctx.fillText(magnitudeText, textX, textY);
            }
          }
        }
        
        // Update magnitude display
        document.getElementById('charge-magnitude').addEventListener('input', (e) => {
          document.getElementById('magnitude-value').textContent = e.target.value;
        });
        
        // Mouse move handler for field display
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          mouseX = e.clientX - rect.left;
          mouseY = e.clientY - rect.top;
          draw();
        });
        
        canvas.addEventListener('mouseleave', () => {
          mouseX = -1;
          mouseY = -1;
          draw();
        });
        
        // Add click handler
        canvas.addEventListener('click', (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const type = document.getElementById('charge-type').value;
          const magnitude = parseFloat(document.getElementById('charge-magnitude').value);
          
          // Add charge to array
          charges.push({
            x: x,
            y: y,
            q: type === 'positive' ? magnitude : -magnitude
          });
          
          draw();
        });
        
        // Clear button
        document.getElementById('clear-field').addEventListener('click', () => {
          charges = [];
          mouseX = -1;
          mouseY = -1;
          draw();
        });
        
        // Initial draw
        draw();
        
        // Expose redraw function globally for re-activation
        window.redrawElectricField = draw;
      }

      let fluxCanvasInitialized = false;
      function initFlux() {
        const canvas = document.getElementById('flux-canvas');
        if (!canvas || fluxCanvasInitialized) return;
        fluxCanvasInitialized = true;
        
        const ctx = canvas.getContext('2d');
        const isDark = document.body.classList.contains('dark');
        
        // Shape state
        let currentShape = {
          type: 'rectangle',
          centerX: canvas.width / 2,
          centerY: canvas.height / 2,
          width: 200,
          height: 100,
          radius: 80,
          angle: 0,
          points: [] // For custom drawn shapes
        };
        
        let isDrawing = false;
        let drawingPoints = [];
        
        // Calculate area of a polygon using shoelace formula
        function calculatePolygonArea(points) {
          if (points.length < 3) return 0;
          let area = 0;
          for (let i = 0; i < points.length; i++) {
            const j = (i + 1) % points.length;
            area += points[i].x * points[j].y;
            area -= points[j].x * points[i].y;
          }
          return Math.abs(area) / 2;
        }
        
        // 3D rotation functions
        function rotateX(point, angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          return {
            x: point.x,
            y: point.y * cos - point.z * sin,
            z: point.y * sin + point.z * cos
          };
        }
        
        function rotateY(point, angle) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          return {
            x: point.x * cos + point.z * sin,
            y: point.y,
            z: -point.x * sin + point.z * cos
          };
        }
        
        // Project 3D point to 2D screen coordinates
        function project3D(point, cameraZ) {
          const scale = cameraZ / (cameraZ + point.z);
          return {
            x: point.x * scale + canvas.width / 2,
            y: point.y * scale + canvas.height / 2,
            z: point.z
          };
        }
        
        // Get electric field at a point (x, y) in 2D canvas coordinates
        function getFieldAtPoint(x, y) {
          const fieldType = document.getElementById('flux-field-type').value;
          let fieldStrength;
          
          // For nonuniform fields, use a base strength (not from slider)
          if (fieldType === 'nonuniform-radial' || fieldType === 'nonuniform-varying') {
            fieldStrength = 10; // Base strength for nonuniform fields
          } else {
            fieldStrength = parseFloat(document.getElementById('flux-field-strength').value);
          }
          
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          
          if (fieldType === 'uniform-vertical') {
            // Vertical field pointing up
            return { 
              x: 0, 
              y: -fieldStrength, 
              magnitude: fieldStrength 
            };
          } else if (fieldType === 'uniform-diagonal') {
            // Diagonal field at specified angle
            const fieldAngle = parseFloat(document.getElementById('flux-field-angle').value) * Math.PI / 180;
            return {
              x: fieldStrength * Math.cos(fieldAngle),
              y: fieldStrength * Math.sin(fieldAngle),
              magnitude: fieldStrength
            };
          } else if (fieldType === 'nonuniform-radial') {
            // Radial field (pointing outward from center)
            const dx = x - centerX;
            const dy = y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 1) dist = 1; // Avoid division by zero
            const strength = fieldStrength * (100 / dist); // Stronger near center
            return {
              x: (dx / dist) * strength,
              y: (dy / dist) * strength,
              magnitude: strength
            };
          } else if (fieldType === 'nonuniform-varying') {
            // Varying strength field (stronger in some areas)
            const dx = x - centerX;
            const dy = y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            // Vary strength based on position (sinusoidal pattern)
            const variation = 1 + 0.5 * Math.sin(dist / 50) * Math.cos((x + y) / 100);
            const strength = fieldStrength * variation;
            // Field still points upward but with varying strength
            return {
              x: 0,
              y: -strength,
              magnitude: strength
            };
          }
          
          return { x: 0, y: -fieldStrength, magnitude: fieldStrength };
        }
        
        // Calculate flux
        function calculateFlux() {
          const fieldType = document.getElementById('flux-field-type').value;
          let fieldStrength;
          
          // For nonuniform fields, use a base strength (not from slider)
          if (fieldType === 'nonuniform-radial' || fieldType === 'nonuniform-varying') {
            fieldStrength = 10; // Base strength for nonuniform fields
          } else {
            fieldStrength = parseFloat(document.getElementById('flux-field-strength').value);
          }
          
          const shapeType = document.getElementById('flux-shape-type').value;
          const viewMode = document.getElementById('flux-view-mode').value;
          let area = 0;
          
          if (shapeType === 'rectangle') {
            area = currentShape.width * currentShape.height;
          } else if (shapeType === 'circle') {
            area = Math.PI * currentShape.radius * currentShape.radius;
          } else if (shapeType === 'triangle') {
            const side = currentShape.width;
            area = (Math.sqrt(3) / 4) * side * side;
          } else if (shapeType === 'draw' && currentShape.points.length >= 3) {
            area = calculatePolygonArea(currentShape.points);
          }
          
          // Convert pixels to meters
          const areaM2 = area * 0.0001;
          
          let flux = 0;
          
          // For nonuniform fields, we need to integrate over the surface
          if (fieldType === 'nonuniform-radial' || fieldType === 'nonuniform-varying') {
            // Sample points on the surface and calculate flux at each point
            const numSamples = 100;
            let totalFlux = 0;
            
            if (shapeType === 'rectangle') {
              const w = currentShape.width;
              const h = currentShape.height;
              const samplesPerSide = Math.floor(Math.sqrt(numSamples));
              for (let i = 0; i < samplesPerSide; i++) {
                for (let j = 0; j < samplesPerSide; j++) {
                  const x = currentShape.centerX - w/2 + (i / samplesPerSide) * w;
                  const y = currentShape.centerY - h/2 + (j / samplesPerSide) * h;
                  const field = getFieldAtPoint(x, y);
                  const normal = { x: 0, y: -1 }; // Normal pointing up in 2D
                  const dot = field.x * normal.x + field.y * normal.y;
                  totalFlux += dot;
                }
              }
              flux = (totalFlux / numSamples) * areaM2;
            } else if (shapeType === 'circle') {
              const r = currentShape.radius;
              for (let i = 0; i < numSamples; i++) {
                const angle = (i / numSamples) * Math.PI * 2;
                const dist = Math.random() * r;
                const x = currentShape.centerX + Math.cos(angle) * dist;
                const y = currentShape.centerY + Math.sin(angle) * dist;
                const field = getFieldAtPoint(x, y);
                const normal = { x: 0, y: -1 };
                const dot = field.x * normal.x + field.y * normal.y;
                totalFlux += dot;
              }
              flux = (totalFlux / numSamples) * areaM2;
            } else {
              // For other shapes, use average field at center
              const field = getFieldAtPoint(currentShape.centerX, currentShape.centerY);
              const normal = { x: 0, y: -1 };
              const dot = field.x * normal.x + field.y * normal.y;
              flux = dot * areaM2;
            }
          } else {
            // For uniform fields, calculate normally
            let angle = 0;
            let fieldVec = { x: 0, y: -1 }; // Default vertical
            
            if (fieldType === 'uniform-diagonal') {
              const fieldAngle = parseFloat(document.getElementById('flux-field-angle').value) * Math.PI / 180;
              fieldVec = {
                x: Math.cos(fieldAngle),
                y: Math.sin(fieldAngle)
              };
            }
            
            // Calculate angle based on view mode
            if (viewMode === '3d') {
              const rotX = parseFloat(document.getElementById('flux-rotation-x').value) * Math.PI / 180;
              const rotY = parseFloat(document.getElementById('flux-rotation-y').value) * Math.PI / 180;
              
              let normal = { x: 0, y: 0, z: 1 };
              normal = rotateX(normal, rotX);
              normal = rotateY(normal, rotY);
              
              // Convert 2D field vector to 3D
              const fieldVec3D = { x: fieldVec.x, y: fieldVec.y, z: 0 };
              
              const dot = fieldVec3D.x * normal.x + fieldVec3D.y * normal.y + fieldVec3D.z * normal.z;
              angle = Math.acos(Math.max(-1, Math.min(1, dot)));
            } else {
              angle = parseFloat(document.getElementById('flux-angle').value) * Math.PI / 180;
              
              if (shapeType === 'circle') {
                angle = 0;
              } else if (shapeType === 'draw' && currentShape.points.length >= 3) {
                let avgNormalX = 0, avgNormalY = 0;
                for (let i = 0; i < currentShape.points.length; i++) {
                  const j = (i + 1) % currentShape.points.length;
                  const dx = currentShape.points[j].x - currentShape.points[i].x;
                  const dy = currentShape.points[j].y - currentShape.points[i].y;
                  const len = Math.sqrt(dx * dx + dy * dy);
                  if (len > 0) {
                    avgNormalX += -dy / len;
                    avgNormalY += dx / len;
                  }
                }
                const normalLen = Math.sqrt(avgNormalX * avgNormalX + avgNormalY * avgNormalY);
                if (normalLen > 0) {
                  avgNormalX /= normalLen;
                  avgNormalY /= normalLen;
                }
                const dot = fieldVec.x * avgNormalX + fieldVec.y * avgNormalY;
                angle = Math.acos(Math.max(-1, Math.min(1, dot)));
              }
            }
            
            flux = fieldStrength * areaM2 * Math.cos(angle);
          }
          
          return { flux, area, areaM2 };
        }
        
        // Draw field lines based on field type
        function drawFieldLines(viewMode, cameraZ) {
          const fieldType = document.getElementById('flux-field-type').value;
          ctx.strokeStyle = isDark ? 'rgba(110, 231, 183, 0.4)' : 'rgba(38, 166, 154, 0.4)';
          ctx.fillStyle = isDark ? 'rgba(110, 231, 183, 0.6)' : 'rgba(38, 166, 154, 0.6)';
          ctx.lineWidth = 2;
          
          if (fieldType === 'uniform-vertical') {
            // Vertical field lines
            for (let x = 50; x < canvas.width; x += 40) {
              if (viewMode === '3d') {
                for (let y = 50; y < canvas.height; y += 80) {
                  const start3D = { x: x - canvas.width / 2, y: y - canvas.height / 2, z: 0 };
                  const end3D = { x: x - canvas.width / 2, y: y - canvas.height / 2 - 30, z: 0 };
                  const start2D = project3D(start3D, cameraZ);
                  const end2D = project3D(end3D, cameraZ);
                  drawArrow(start2D.x, start2D.y, end2D.x, end2D.y);
                }
              } else {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                for (let y = 30; y < canvas.height; y += 60) {
                  drawArrow(x, y, x, y - 15);
                }
              }
            }
          } else if (fieldType === 'uniform-diagonal') {
            // Diagonal field lines - draw parallel lines across the canvas
            const fieldAngle = parseFloat(document.getElementById('flux-field-angle').value) * Math.PI / 180;
            const spacing = 40;
            const perpAngle = fieldAngle + Math.PI / 2; // Perpendicular to field direction
            
            // Calculate how many lines we need
            const diagonal = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
            const numLines = Math.ceil(diagonal / spacing);
            
            for (let i = -numLines; i <= numLines; i++) {
              // Start point on one edge
              let startX, startY, endX, endY;
              
              // Find intersection with canvas edges
              const offset = i * spacing;
              const cosPerp = Math.cos(perpAngle);
              const sinPerp = Math.sin(perpAngle);
              
              // Try different edge intersections
              const intersections = [];
              
              // Top edge (y = 0)
              const t1 = -offset / sinPerp;
              if (t1 >= 0 && t1 <= canvas.width) {
                intersections.push({ x: t1, y: 0 });
              }
              
              // Bottom edge (y = canvas.height)
              const t2 = (canvas.height - offset) / sinPerp;
              if (t2 >= 0 && t2 <= canvas.width) {
                intersections.push({ x: t2, y: canvas.height });
              }
              
              // Left edge (x = 0)
              const t3 = -offset / cosPerp;
              if (t3 >= 0 && t3 <= canvas.height) {
                intersections.push({ x: 0, y: t3 });
              }
              
              // Right edge (x = canvas.width)
              const t4 = (canvas.width - offset) / cosPerp;
              if (t4 >= 0 && t4 <= canvas.height) {
                intersections.push({ x: canvas.width, y: t4 });
              }
              
              if (intersections.length >= 2) {
                startX = intersections[0].x;
                startY = intersections[0].y;
                endX = intersections[1].x;
                endY = intersections[1].y;
                
                if (viewMode === '3d') {
                  const start3D = { x: startX - canvas.width / 2, y: startY - canvas.height / 2, z: 0 };
                  const end3D = { x: endX - canvas.width / 2, y: endY - canvas.height / 2, z: 0 };
                  const start2D = project3D(start3D, cameraZ);
                  const end2D = project3D(end3D, cameraZ);
                  ctx.beginPath();
                  ctx.moveTo(start2D.x, start2D.y);
                  ctx.lineTo(end2D.x, end2D.y);
                  ctx.stroke();
                  
                  // Draw arrow in field direction
                  const midX = (start2D.x + end2D.x) / 2;
                  const midY = (start2D.y + end2D.y) / 2;
                  const arrowEndX = midX + Math.cos(fieldAngle) * 20;
                  const arrowEndY = midY + Math.sin(fieldAngle) * 20;
                  drawArrow(midX, midY, arrowEndX, arrowEndY);
                } else {
                  ctx.beginPath();
                  ctx.moveTo(startX, startY);
                  ctx.lineTo(endX, endY);
                  ctx.stroke();
                  
                  // Draw arrow in field direction
                  const midX = (startX + endX) / 2;
                  const midY = (startY + endY) / 2;
                  const arrowEndX = midX + Math.cos(fieldAngle) * 20;
                  const arrowEndY = midY + Math.sin(fieldAngle) * 20;
                  drawArrow(midX, midY, arrowEndX, arrowEndY);
                }
              }
            }
          } else if (fieldType === 'nonuniform-radial') {
            // Radial field lines (pointing outward from center)
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw radial lines
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 12) {
              const maxR = Math.min(canvas.width, canvas.height) / 2 - 20;
              const startX = centerX + Math.cos(angle) * 20;
              const startY = centerY + Math.sin(angle) * 20;
              const endX = centerX + Math.cos(angle) * maxR;
              const endY = centerY + Math.sin(angle) * maxR;
              
              if (viewMode === '3d') {
                const start3D = { x: startX - canvas.width / 2, y: startY - canvas.height / 2, z: 0 };
                const end3D = { x: endX - canvas.width / 2, y: endY - canvas.height / 2, z: 0 };
                const start2D = project3D(start3D, cameraZ);
                const end2D = project3D(end3D, cameraZ);
                ctx.beginPath();
                ctx.moveTo(start2D.x, start2D.y);
                ctx.lineTo(end2D.x, end2D.y);
                ctx.stroke();
                
                // Draw arrow pointing outward
                const arrowX = start2D.x + (end2D.x - start2D.x) * 0.7;
                const arrowY = start2D.y + (end2D.y - start2D.y) * 0.7;
                const arrowEndX = arrowX + Math.cos(angle) * 15;
                const arrowEndY = arrowY + Math.sin(angle) * 15;
                drawArrow(arrowX, arrowY, arrowEndX, arrowEndY);
              } else {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // Draw arrow pointing outward
                const arrowX = startX + (endX - startX) * 0.7;
                const arrowY = startY + (endY - startY) * 0.7;
                const arrowEndX = arrowX + Math.cos(angle) * 15;
                const arrowEndY = arrowY + Math.sin(angle) * 15;
                drawArrow(arrowX, arrowY, arrowEndX, arrowEndY);
              }
            }
          } else if (fieldType === 'nonuniform-varying') {
            // Varying strength field (vertical with varying intensity)
            // Use a base strength of 10 for visualization
            const baseStrength = 10;
            for (let x = 50; x < canvas.width; x += 40) {
              for (let y = 50; y < canvas.height; y += 60) {
                const field = getFieldAtPoint(x, y);
                const intensity = field.magnitude / baseStrength;
                ctx.globalAlpha = 0.3 + Math.min(intensity * 0.4, 0.4);
                ctx.lineWidth = 1 + Math.min(intensity * 2, 3);
                
                if (viewMode === '3d') {
                  const start3D = { x: x - canvas.width / 2, y: y - canvas.height / 2, z: 0 };
                  const end3D = { x: x - canvas.width / 2, y: y - canvas.height / 2 - 30, z: 0 };
                  const start2D = project3D(start3D, cameraZ);
                  const end2D = project3D(end3D, cameraZ);
                  drawArrow(start2D.x, start2D.y, end2D.x, end2D.y);
                } else {
                  drawArrow(x, y, x, y - 20);
                }
              }
            }
            ctx.globalAlpha = 1;
            ctx.lineWidth = 2;
          }
        }
        
        // Helper function to draw an arrow
        function drawArrow(x1, y1, x2, y2) {
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          
          const angle = Math.atan2(y2 - y1, x2 - x1);
          ctx.beginPath();
          ctx.moveTo(x2, y2);
          ctx.lineTo(x2 - 8 * Math.cos(angle - Math.PI / 6), y2 - 8 * Math.sin(angle - Math.PI / 6));
          ctx.lineTo(x2 - 8 * Math.cos(angle + Math.PI / 6), y2 - 8 * Math.sin(angle + Math.PI / 6));
          ctx.closePath();
          ctx.fill();
        }
        
        function drawFlux() {
          ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          const viewMode = document.getElementById('flux-view-mode').value;
          const shapeType = document.getElementById('flux-shape-type').value;
          const cameraZ = 800; // Camera distance for 3D projection
          
          // Draw field lines
          drawFieldLines(viewMode, cameraZ);
          
          if (viewMode === '3d') {
            // 3D rendering
            const rotX = parseFloat(document.getElementById('flux-rotation-x').value) * Math.PI / 180;
            const rotY = parseFloat(document.getElementById('flux-rotation-y').value) * Math.PI / 180;
            
            // Draw 3D shape
            ctx.fillStyle = isDark ? 'rgba(129, 140, 248, 0.3)' : 'rgba(26, 35, 126, 0.2)';
            ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.8)' : 'rgba(26, 35, 126, 0.8)';
            ctx.lineWidth = 3;
            
            let shapePoints3D = [];
            let normal3D = { x: 0, y: 0, z: 1 };
            
            if (shapeType === 'rectangle') {
              const w = currentShape.width / 2;
              const h = currentShape.height / 2;
              shapePoints3D = [
                { x: -w, y: -h, z: 0 },
                { x: w, y: -h, z: 0 },
                { x: w, y: h, z: 0 },
                { x: -w, y: h, z: 0 }
              ];
            } else if (shapeType === 'circle') {
              // Create circle as polygon with many sides
              const numSides = 32;
              for (let i = 0; i < numSides; i++) {
                const angle = (i / numSides) * Math.PI * 2;
                shapePoints3D.push({
                  x: currentShape.radius * Math.cos(angle),
                  y: currentShape.radius * Math.sin(angle),
                  z: 0
                });
              }
            } else if (shapeType === 'triangle') {
              const side = currentShape.width;
              const height = (Math.sqrt(3) / 2) * side;
              shapePoints3D = [
                { x: 0, y: -height * 2/3, z: 0 },
                { x: -side / 2, y: height / 3, z: 0 },
                { x: side / 2, y: height / 3, z: 0 }
              ];
            }
            
            // Rotate shape points and normal
            shapePoints3D = shapePoints3D.map(p => {
              let rotated = rotateX(p, rotX);
              rotated = rotateY(rotated, rotY);
              // Center the shape
              rotated.x += currentShape.centerX - canvas.width / 2;
              rotated.y += currentShape.centerY - canvas.height / 2;
              return rotated;
            });
            normal3D = rotateX(normal3D, rotX);
            normal3D = rotateY(normal3D, rotY);
            
            // Project to 2D
            const shapePoints2D = shapePoints3D.map(p => project3D(p, cameraZ));
            
            // Draw shape
            if (shapePoints2D.length > 0) {
              ctx.beginPath();
              ctx.moveTo(shapePoints2D[0].x, shapePoints2D[0].y);
              for (let i = 1; i < shapePoints2D.length; i++) {
                ctx.lineTo(shapePoints2D[i].x, shapePoints2D[i].y);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            }
            
            // Draw normal vector in 3D
            const shapeCenterX = currentShape.centerX - canvas.width / 2;
            const shapeCenterY = currentShape.centerY - canvas.height / 2;
            const normalStart3D = { x: shapeCenterX, y: shapeCenterY, z: 0 };
            const normalEnd3D = {
              x: shapeCenterX + normal3D.x * 60,
              y: shapeCenterY + normal3D.y * 60,
              z: normal3D.z * 60
            };
            const normalStart2D = project3D(normalStart3D, cameraZ);
            const normalEnd2D = project3D(normalEnd3D, cameraZ);
            
            ctx.strokeStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
            ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(normalStart2D.x, normalStart2D.y);
            ctx.lineTo(normalEnd2D.x, normalEnd2D.y);
            ctx.stroke();
            
            // Arrowhead
            const normalAngle = Math.atan2(normalEnd2D.y - normalStart2D.y, normalEnd2D.x - normalStart2D.x);
            ctx.beginPath();
            ctx.moveTo(normalEnd2D.x, normalEnd2D.y);
            ctx.lineTo(normalEnd2D.x - 8 * Math.cos(normalAngle - Math.PI / 6), normalEnd2D.y - 8 * Math.sin(normalAngle - Math.PI / 6));
            ctx.lineTo(normalEnd2D.x - 8 * Math.cos(normalAngle + Math.PI / 6), normalEnd2D.y - 8 * Math.sin(normalAngle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
            
            // Label
            ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.9)' : 'rgba(245, 158, 11, 0.9)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('n', normalEnd2D.x + 10, normalEnd2D.y);
            
          } else {
            // 2D rendering
            const angle = parseFloat(document.getElementById('flux-angle').value) * Math.PI / 180;
            
            // Draw shape
            ctx.save();
            ctx.translate(currentShape.centerX, currentShape.centerY);
            ctx.rotate(angle);
            
            ctx.fillStyle = isDark ? 'rgba(129, 140, 248, 0.3)' : 'rgba(26, 35, 126, 0.2)';
            ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.8)' : 'rgba(26, 35, 126, 0.8)';
            ctx.lineWidth = 3;
            
            if (shapeType === 'rectangle') {
              ctx.fillRect(-currentShape.width / 2, -currentShape.height / 2, currentShape.width, currentShape.height);
              ctx.strokeRect(-currentShape.width / 2, -currentShape.height / 2, currentShape.width, currentShape.height);
            } else if (shapeType === 'circle') {
              ctx.beginPath();
              ctx.arc(0, 0, currentShape.radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
            } else if (shapeType === 'triangle') {
              ctx.beginPath();
              const side = currentShape.width;
              const height = (Math.sqrt(3) / 2) * side;
              ctx.moveTo(0, -height * 2/3);
              ctx.lineTo(-side / 2, height / 3);
              ctx.lineTo(side / 2, height / 3);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            } else if (shapeType === 'draw' && currentShape.points.length >= 3) {
              ctx.restore();
              ctx.save();
              ctx.translate(currentShape.centerX, currentShape.centerY);
              
              ctx.beginPath();
              const transformedPoints = currentShape.points.map(p => ({
                x: p.x - currentShape.centerX,
                y: p.y - currentShape.centerY
              }));
              
              ctx.moveTo(transformedPoints[0].x, transformedPoints[0].y);
              for (let i = 1; i < transformedPoints.length; i++) {
                ctx.lineTo(transformedPoints[i].x, transformedPoints[i].y);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            }
            
            // Draw normal vector for preset shapes
            if (shapeType !== 'draw') {
              ctx.strokeStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
              ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(0, -60);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(0, -60);
              ctx.lineTo(-5, -50);
              ctx.lineTo(5, -50);
              ctx.closePath();
              ctx.fill();
              ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.9)' : 'rgba(245, 158, 11, 0.9)';
              ctx.font = '12px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('n', 0, -75);
            }
            
            ctx.restore();
          }
          
          // Update flux display
          const { flux } = calculateFlux();
          document.getElementById('flux-value').textContent = flux.toFixed(2);
        }
        
        // Handle view mode change
        document.getElementById('flux-view-mode').addEventListener('change', (e) => {
          const viewMode = e.target.value;
          const angleGroup = document.getElementById('flux-angle-group');
          const controls3D = document.getElementById('flux-3d-controls');
          const controls3DY = document.getElementById('flux-3d-controls-y');
          const shapeTypeSelect = document.getElementById('flux-shape-type');
          const drawOption = shapeTypeSelect.querySelector('option[value="draw"]');
          
          if (viewMode === '3d') {
            angleGroup.style.display = 'none';
            controls3D.style.display = 'flex';
            controls3DY.style.display = 'flex';
            
            // Disable draw option in 3D mode
            if (drawOption) {
              drawOption.disabled = true;
            }
            
            // If draw is currently selected, switch to rectangle
            if (shapeTypeSelect.value === 'draw') {
              shapeTypeSelect.value = 'rectangle';
              currentShape.type = 'rectangle';
              currentShape.width = 200;
              currentShape.height = 100;
              currentShape.centerX = canvas.width / 2;
              currentShape.centerY = canvas.height / 2;
              currentShape.points = [];
              drawingPoints = [];
              canvas.style.cursor = 'move';
            }
          } else {
            angleGroup.style.display = 'flex';
            controls3D.style.display = 'none';
            controls3DY.style.display = 'none';
            
            // Enable draw option in 2D mode
            if (drawOption) {
              drawOption.disabled = false;
            }
          }
          
          drawFlux();
        });
        
        // Handle 3D rotation controls
        document.getElementById('flux-rotation-x').addEventListener('input', (e) => {
          document.getElementById('flux-rotation-x-value').textContent = e.target.value;
          drawFlux();
        });
        
        document.getElementById('flux-rotation-y').addEventListener('input', (e) => {
          document.getElementById('flux-rotation-y-value').textContent = e.target.value;
          drawFlux();
        });
        
        // Handle field type change
        document.getElementById('flux-field-type').addEventListener('change', (e) => {
          const fieldType = e.target.value;
          const fieldAngleGroup = document.getElementById('flux-field-angle-group');
          const fieldStrengthGroup = document.getElementById('flux-field-strength-group');
          
          if (fieldType === 'uniform-diagonal') {
            fieldAngleGroup.style.display = 'flex';
            fieldStrengthGroup.style.display = 'flex';
          } else if (fieldType === 'nonuniform-radial' || fieldType === 'nonuniform-varying') {
            fieldAngleGroup.style.display = 'none';
            fieldStrengthGroup.style.display = 'none';
          } else {
            fieldAngleGroup.style.display = 'none';
            fieldStrengthGroup.style.display = 'flex';
          }
          
          drawFlux();
        });
        
        // Handle field angle change
        document.getElementById('flux-field-angle').addEventListener('input', (e) => {
          document.getElementById('flux-field-angle-value').textContent = e.target.value;
          drawFlux();
        });
        
        // Handle shape type change
        document.getElementById('flux-shape-type').addEventListener('change', (e) => {
          const shapeType = e.target.value;
          const viewMode = document.getElementById('flux-view-mode').value;
          currentShape.type = shapeType;
          
          // Show/hide angle control based on shape type and view mode
          const angleGroup = document.getElementById('flux-angle-group');
          if (shapeType === 'draw' || viewMode === '3d') {
            angleGroup.style.display = 'none';
            currentShape.angle = 0;
          } else {
            angleGroup.style.display = 'flex';
          }
          
          if (shapeType === 'draw') {
            canvas.style.cursor = 'crosshair';
          } else {
            canvas.style.cursor = 'move';
          }
          
          // Reset shape for preset types
          if (shapeType === 'rectangle') {
            currentShape.width = 200;
            currentShape.height = 100;
            currentShape.centerX = canvas.width / 2;
            currentShape.centerY = canvas.height / 2;
          } else if (shapeType === 'circle') {
            currentShape.radius = 80;
            currentShape.centerX = canvas.width / 2;
            currentShape.centerY = canvas.height / 2;
          } else if (shapeType === 'triangle') {
            currentShape.width = 150;
            currentShape.centerX = canvas.width / 2;
            currentShape.centerY = canvas.height / 2;
          } else if (shapeType === 'draw') {
            currentShape.points = [];
            drawingPoints = [];
          }
          
          drawFlux();
        });
        
        // Canvas interaction for drawing
        canvas.addEventListener('mousedown', (e) => {
          const viewMode = document.getElementById('flux-view-mode').value;
          const shapeType = document.getElementById('flux-shape-type').value;
          
          // Drawing only works in 2D mode
          if (shapeType === 'draw' && viewMode === '2d') {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            drawingPoints = [{ x, y }];
            currentShape.points = [{ x, y }];
            currentShape.centerX = x;
            currentShape.centerY = y;
          } else if (viewMode === '3d' || shapeType !== 'draw') {
            // For preset shapes, allow dragging to position
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Check if clicking on shape
            const dx = mouseX - currentShape.centerX;
            const dy = mouseY - currentShape.centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (document.getElementById('flux-shape-type').value === 'circle') {
              if (dist <= currentShape.radius) {
                isDrawing = true;
              }
            } else {
              // For rectangle and triangle, check if inside bounding box
              const halfW = currentShape.width / 2;
              const halfH = currentShape.height / 2;
              if (Math.abs(dx) <= halfW && Math.abs(dy) <= halfH) {
                isDrawing = true;
              }
            }
          }
        });
        
        canvas.addEventListener('mousemove', (e) => {
          if (isDrawing) {
            const viewMode = document.getElementById('flux-view-mode').value;
            const shapeType = document.getElementById('flux-shape-type').value;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Drawing only works in 2D mode
            if (shapeType === 'draw' && viewMode === '2d') {
              drawingPoints.push({ x, y });
              currentShape.points = [...drawingPoints];
              
              // Update center to centroid
              if (currentShape.points.length > 0) {
                let sumX = 0, sumY = 0;
                currentShape.points.forEach(p => {
                  sumX += p.x;
                  sumY += p.y;
                });
                currentShape.centerX = sumX / currentShape.points.length;
                currentShape.centerY = sumY / currentShape.points.length;
              }
            } else if (viewMode === '3d' || shapeType !== 'draw') {
              // Move shape (only in 2D mode for preset shapes)
              if (viewMode === '2d') {
                currentShape.centerX = x;
                currentShape.centerY = y;
              }
            }
            
            drawFlux();
          }
        });
        
        canvas.addEventListener('mouseup', () => {
          isDrawing = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
          isDrawing = false;
        });
        
        // Clear button
        document.getElementById('clear-flux-shape').addEventListener('click', () => {
          const shapeType = document.getElementById('flux-shape-type').value;
          currentShape.points = [];
          drawingPoints = [];
          currentShape.centerX = canvas.width / 2;
          currentShape.centerY = canvas.height / 2;
          if (shapeType === 'rectangle') {
            currentShape.width = 200;
            currentShape.height = 100;
          } else if (shapeType === 'circle') {
            currentShape.radius = 80;
          } else if (shapeType === 'triangle') {
            currentShape.width = 150;
          }
          drawFlux();
        });
        
        // Set initial cursor
        canvas.style.cursor = 'move';
        
        drawFlux();
        document.getElementById('flux-field-strength').addEventListener('input', (e) => {
          document.getElementById('flux-field-value').textContent = e.target.value;
          drawFlux();
        });
        document.getElementById('flux-angle').addEventListener('input', (e) => {
          document.getElementById('flux-angle-value').textContent = e.target.value;
          drawFlux();
        });
      }

      let voltageCanvasInitialized = false;
      let voltageCharges = [];
      let voltageMouseX = -1;
      let voltageMouseY = -1;
      
      function initVoltage() {
        const canvas = document.getElementById('voltage-canvas');
        if (!canvas || voltageCanvasInitialized) return;
        voltageCanvasInitialized = true;
        
        const ctx = canvas.getContext('2d');
        const isDark = document.body.classList.contains('dark');
        
        // Constants
        const k = 9e9; // Coulomb's constant (scaled for visualization)
        const voltageStep = 5; // Voltage difference between equipotential lines (in scaled units)
        const minVoltage = -100; // Minimum voltage to display
        const maxVoltage = 100; // Maximum voltage to display
        
        // Calculate voltage at a point
        function calculateVoltage(x, y) {
          let V = 0;
          for (const charge of voltageCharges) {
            const dx = x - charge.x;
            const dy = y - charge.y;
            const r2 = dx * dx + dy * dy;
            if (r2 < 1) continue; // Avoid division by zero
            
            const r = Math.sqrt(r2);
            // V = kq/r (scaled for visualization to give reasonable values ~0-100V)
            // Using larger scaling factor to get realistic voltage values
            V += (k * charge.q) / (r * 1e7);
          }
          return V;
        }
        
        // Track whether to show field lines
        let showFieldLines = false;
        
        // Calculate electric field at a point
        function calculateField(x, y) {
          let Ex = 0, Ey = 0;
          for (const charge of voltageCharges) {
            const dx = x - charge.x;
            const dy = y - charge.y;
            const r2 = dx * dx + dy * dy;
            if (r2 < 1) continue; // Avoid division by zero
            
            const r = Math.sqrt(r2);
            const magnitude = (k * charge.q) / (r2 * 1e6); // Scale down for visualization
            Ex += magnitude * (dx / r);
            Ey += magnitude * (dy / r);
          }
          return { Ex, Ey, magnitude: Math.sqrt(Ex * Ex + Ey * Ey) };
        }
        
        // Draw a single field vector (arrow)
        function drawFieldVector(x, y, field) {
          if (field.magnitude < 0.01) return; // Skip very small fields
          
          // Scale the vector length (cap at max length)
          const maxLength = 30;
          const minLength = 5;
          const scale = 20; // Scale factor for visualization
          let length = Math.min(field.magnitude * scale, maxLength);
          if (length < minLength) length = minLength;
          
          // Calculate angle
          const angle = Math.atan2(field.Ey, field.Ex);
          
          // Draw arrow shaft
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(
            x + length * Math.cos(angle),
            y + length * Math.sin(angle)
          );
          ctx.stroke();
          
          // Draw arrowhead
          const arrowSize = 6;
          const arrowAngle = Math.PI / 6; // 30 degrees
          
          const tipX = x + length * Math.cos(angle);
          const tipY = y + length * Math.sin(angle);
          
          ctx.beginPath();
          ctx.moveTo(tipX, tipY);
          ctx.lineTo(
            tipX - arrowSize * Math.cos(angle - arrowAngle),
            tipY - arrowSize * Math.sin(angle - arrowAngle)
          );
          ctx.lineTo(
            tipX - arrowSize * Math.cos(angle + arrowAngle),
            tipY - arrowSize * Math.sin(angle + arrowAngle)
          );
          ctx.closePath();
          ctx.fill();
        }
        
        // Draw electric field vectors on a grid
        function drawFieldVectors() {
          if (voltageCharges.length === 0 || !showFieldLines) return;
          
          ctx.strokeStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
          ctx.fillStyle = isDark ? 'rgba(251, 191, 36, 0.8)' : 'rgba(245, 158, 11, 0.8)';
          ctx.lineWidth = 2;
          
          // Grid spacing for vectors
          const gridSpacing = 40; // Space between vectors
          
          // Draw vectors on a grid
          for (let y = gridSpacing; y < canvas.height - gridSpacing; y += gridSpacing) {
            for (let x = gridSpacing; x < canvas.width - gridSpacing; x += gridSpacing) {
              // Check if too close to any charge
              let tooClose = false;
              for (const charge of voltageCharges) {
                const dist = Math.sqrt((x - charge.x) ** 2 + (y - charge.y) ** 2);
                if (dist < 20) {
                  tooClose = true;
                  break;
                }
              }
              
              if (!tooClose) {
                const field = calculateField(x, y);
                drawFieldVector(x, y, field);
              }
            }
          }
        }
        
        // Draw equipotential lines
        function drawEquipotentials() {
          if (voltageCharges.length === 0) return;
          
          ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.7)' : 'rgba(26, 35, 126, 0.7)';
          ctx.lineWidth = 2;
          
          // For single charge: draw concentric circles
          if (voltageCharges.length === 1) {
            const charge = voltageCharges[0];
            const numCircles = Math.min(15, Math.floor(Math.abs(charge.q) * 2.5));
            const baseRadius = 25;
            
            for (let i = 1; i <= numCircles; i++) {
              const radius = baseRadius + i * 20;
              if (radius > Math.min(canvas.width, canvas.height) * 0.45) break;
              
              // Check if circle is within bounds
              if (charge.x - radius < 0 || charge.x + radius > canvas.width ||
                  charge.y - radius < 0 || charge.y + radius > canvas.height) {
                continue;
              }
              
              ctx.beginPath();
              ctx.arc(charge.x, charge.y, radius, 0, Math.PI * 2);
              ctx.stroke();
            }
          } else {
            // For multiple charges: use contour tracing with grid sampling
            const gridSize = 8; // Coarser grid for performance
            const voltageMap = [];
            
            // Sample voltage values
            for (let y = 0; y < canvas.height; y += gridSize) {
              voltageMap[y] = [];
              for (let x = 0; x < canvas.width; x += gridSize) {
                voltageMap[y][x] = calculateVoltage(x, y);
              }
            }
            
            // Find min and max voltage
            let minV = Infinity;
            let maxV = -Infinity;
            for (let y = 0; y < canvas.height; y += gridSize) {
              for (let x = 0; x < canvas.width; x += gridSize) {
                if (voltageMap[y] && voltageMap[y][x] !== undefined) {
                  minV = Math.min(minV, voltageMap[y][x]);
                  maxV = Math.max(maxV, voltageMap[y][x]);
                }
              }
            }
            
            // Draw equipotential lines at regular intervals
            const numLines = 12;
            const voltageRange = maxV - minV;
            if (voltageRange > 0) {
              const step = voltageRange / (numLines + 1);
              
              for (let i = 1; i <= numLines; i++) {
                const targetVoltage = minV + i * step;
                
                // Draw contour using simple method: find points where voltage crosses target
                ctx.beginPath();
                let firstPoint = true;
                
                for (let y = gridSize; y < canvas.height - gridSize; y += gridSize) {
                  for (let x = gridSize; x < canvas.width - gridSize; x += gridSize) {
                    const v = voltageMap[y]?.[x] ?? 0;
                    const vRight = voltageMap[y]?.[x + gridSize] ?? 0;
                    const vDown = voltageMap[y + gridSize]?.[x] ?? 0;
                    
                    // Check if we cross the target voltage
                    if ((v < targetVoltage && vRight >= targetVoltage) ||
                        (v >= targetVoltage && vRight < targetVoltage) ||
                        (v < targetVoltage && vDown >= targetVoltage) ||
                        (v >= targetVoltage && vDown < targetVoltage)) {
                      if (firstPoint) {
                        ctx.moveTo(x, y);
                        firstPoint = false;
                      } else {
                        ctx.lineTo(x, y);
                      }
                    }
                  }
                }
                
                if (!firstPoint) {
                  ctx.stroke();
                }
              }
            }
          }
        }
        
        // Draw voltage color map (heat map) - optimized with coarser grid
        function drawVoltageMap() {
          const imageData = ctx.createImageData(canvas.width, canvas.height);
          const data = imageData.data;
          
          // Use a coarser grid for performance (sample every 4 pixels)
          const gridStep = 4;
          
          // Find min and max voltage for color scaling (sample first)
          let minV = Infinity;
          let maxV = -Infinity;
          
          for (let y = 0; y < canvas.height; y += gridStep) {
            for (let x = 0; x < canvas.width; x += gridStep) {
              const V = calculateVoltage(x, y);
              minV = Math.min(minV, V);
              maxV = Math.max(maxV, V);
            }
          }
          
          const range = maxV - minV || 1;
          const zeroPoint = -minV / range; // Normalized zero point
          
          // Draw color map using grid sampling
          for (let y = 0; y < canvas.height; y += gridStep) {
            for (let x = 0; x < canvas.width; x += gridStep) {
              const V = calculateVoltage(x, y);
              const normalized = (V - minV) / range; // 0 to 1
              
              // Color scheme: blue (negative/low) -> white (zero) -> red (positive/high)
              let r, g, b, a = 60; // 60/255 opacity
              
              if (normalized < zeroPoint) {
                // Blue to white (negative voltages)
                const t = normalized / zeroPoint;
                r = Math.floor(t * 200);
                g = Math.floor(t * 200);
                b = 255;
              } else {
                // White to red (positive voltages)
                const t = (normalized - zeroPoint) / (1 - zeroPoint);
                r = 255;
                g = Math.floor((1 - t) * 200);
                b = Math.floor((1 - t) * 200);
              }
              
              // Fill grid cell
              for (let dy = 0; dy < gridStep && y + dy < canvas.height; dy++) {
                for (let dx = 0; dx < gridStep && x + dx < canvas.width; dx++) {
                  const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                  data[idx] = r;
                  data[idx + 1] = g;
                  data[idx + 2] = b;
                  data[idx + 3] = a;
                }
              }
            }
          }
          
          ctx.putImageData(imageData, 0, 0);
        }
        
        // Main draw function
        function draw() {
          // Clear canvas
          ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          if (voltageCharges.length > 0) {
            // Draw voltage color map
            drawVoltageMap();
            
            // Draw equipotential lines
            drawEquipotentials();
            
            // Draw electric field vectors (if enabled)
            drawFieldVectors();
          }
          
          // Draw charges
          for (const charge of voltageCharges) {
            const radius = 10 + Math.abs(charge.q) * 2;
            ctx.beginPath();
            ctx.arc(charge.x, charge.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = charge.q > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            ctx.fill();
            ctx.strokeStyle = isDark ? '#fff' : '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(charge.q > 0 ? '+' : '-', charge.x, charge.y + 5);
          }
          
          // Draw voltage at mouse position
          if (voltageMouseX >= 0 && voltageMouseY >= 0 && 
              voltageMouseX <= canvas.width && voltageMouseY <= canvas.height) {
            const V = calculateVoltage(voltageMouseX, voltageMouseY);
            
            // Draw voltage text
            ctx.fillStyle = isDark ? '#fbbf24' : '#f59e0b';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            const voltageText = `V = ${V.toFixed(2)} V`;
            const textWidth = ctx.measureText(voltageText).width;
            const padding = 8;
            
            // Draw background
            ctx.fillStyle = isDark ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(voltageMouseX + 10, voltageMouseY - 20, textWidth + padding * 2, 24);
            
            // Draw text
            ctx.fillStyle = isDark ? '#fbbf24' : '#f59e0b';
            ctx.fillText(voltageText, voltageMouseX + 10 + padding, voltageMouseY - 5);
          }
        }
        
        // Update magnitude display
        document.getElementById('voltage-charge-magnitude').addEventListener('input', (e) => {
          document.getElementById('voltage-magnitude-value').textContent = e.target.value;
        });
        
        // Show field lines button toggle
        const showFieldLinesButton = document.getElementById('show-field-lines');
        showFieldLinesButton.addEventListener('click', () => {
          showFieldLines = !showFieldLines;
          showFieldLinesButton.textContent = showFieldLines ? 'Hide E' : 'Show E';
          draw();
        });
        
        // Mouse move handler
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          voltageMouseX = e.clientX - rect.left;
          voltageMouseY = e.clientY - rect.top;
          draw();
        });
        
        canvas.addEventListener('mouseleave', () => {
          voltageMouseX = -1;
          voltageMouseY = -1;
          draw();
        });
        
        // Add click handler
        canvas.addEventListener('click', (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const type = document.getElementById('voltage-charge-type').value;
          const magnitude = parseFloat(document.getElementById('voltage-charge-magnitude').value);
          
          // Add charge to array
          voltageCharges.push({
            x: x,
            y: y,
            q: type === 'positive' ? magnitude : -magnitude
          });
          
          draw();
        });
        
        // Clear button
        document.getElementById('clear-voltage').addEventListener('click', () => {
          voltageCharges = [];
          voltageMouseX = -1;
          voltageMouseY = -1;
          draw();
        });
        
        // Initial draw
        draw();
      }

      let gaussCanvasInitialized = false;
      function initGauss() {
        const canvas = document.getElementById('gauss-canvas');
        if (!canvas || gaussCanvasInitialized) return;
        gaussCanvasInitialized = true;
        
        const ctx = canvas.getContext('2d');
        const isDark = document.body.classList.contains('dark');
        
        // Constants
        const epsilon0 = 8.85e-12; // C²/N⋅m²
        const k = 9e9; // N⋅m²/C²
        const pxToM = 0.01; // Conversion: 1 px = 0.01 m (for visualization)
        
        function updateFormulaDisplay() {
          const chargeType = document.getElementById('gauss-charge-type').value;
          const charge = parseFloat(document.getElementById('gauss-charge').value);
          const chargeParam = document.getElementById('gauss-charge-param') ? parseFloat(document.getElementById('gauss-charge-param').value) : 0;
          const shape = document.getElementById('gauss-shape').value;
          const radius = parseFloat(document.getElementById('gauss-radius').value);
          const height = document.getElementById('gauss-height') ? parseFloat(document.getElementById('gauss-height').value) : 0;
          
          const q = charge * 1e-9; // Convert to Coulombs
          const r = radius * pxToM; // Convert to meters
          const h = height * pxToM; // Convert to meters
          const chargeParamM = chargeParam * pxToM; // Convert charge parameter to meters
          
          // Calculate enclosed charge based on charge type
          let qEnc = 0;
          let chargeDescription = '';
          
          if (chargeType === 'point') {
            qEnc = q;
            chargeDescription = `Point charge: q = ${q.toExponential(2)} C`;
          } else if (chargeType === 'line') {
            // Linear charge density λ = q/L, enclosed charge = λ × length
            const lambda = q / (chargeParamM || 1); // Linear charge density (C/m)
            const length = h || chargeParamM; // Length of Gaussian surface
            qEnc = lambda * length;
            chargeDescription = `Line charge: λ = ${lambda.toExponential(2)} C/m, length = ${length.toFixed(3)} m`;
          } else if (chargeType === 'cylinder') {
            // Volume charge density ρ = q/V, enclosed charge = ρ × volume
            const chargeRadius = chargeParamM;
            const rCharge = chargeRadius;
            const volume = Math.PI * rCharge * rCharge * (h || 1);
            const rho = q / (volume || 1);
            // Enclosed charge if Gaussian surface encloses the charge cylinder
            if (r >= rCharge) {
              qEnc = q;
            } else {
              const encVolume = Math.PI * r * r * (h || 1);
              qEnc = rho * encVolume;
            }
            chargeDescription = `Cylinder charge: ρ = ${rho.toExponential(2)} C/m³, radius = ${rCharge.toFixed(3)} m`;
          } else if (chargeType === 'ring') {
            // Ring charge: total charge q, enclosed if Gaussian surface encloses ring
            const ringRadius = chargeParamM;
            if (r >= ringRadius) {
              qEnc = q;
            } else {
              qEnc = 0; // Ring is outside Gaussian surface
            }
            chargeDescription = `Ring charge: q = ${q.toExponential(2)} C, radius = ${ringRadius.toFixed(3)} m`;
          } else if (chargeType === 'plane') {
            // Surface charge density σ = q/A, enclosed charge = σ × area
            const planeArea = chargeParamM * chargeParamM; // Area of charge plane
            const sigma = q / (planeArea || 1); // Surface charge density (C/m²)
            // For plane, enclosed charge depends on Gaussian surface
            if (shape === 'cylinder') {
              const encArea = Math.PI * r * r; // Area of one cylinder end that intersects plane
              qEnc = sigma * encArea;
            } else {
              qEnc = sigma * (Math.PI * r * r); // Approximate for sphere
            }
            chargeDescription = `Plane charge: σ = ${sigma.toExponential(2)} C/m²`;
          }
          
          const flux = qEnc / epsilon0;
          
          let formulaHTML = '';
          
          // Calculate electric field based on charge type
          let E = 0;
          let fieldFormula = '';
          
          if (chargeType === 'point') {
            E = (k * qEnc) / (r * r);
            fieldFormula = `E = kQ_enc/r² = (9×10⁹ N⋅m²/C²) × (${qEnc.toExponential(2)} C) / (${r.toFixed(3)} m)²`;
          } else if (chargeType === 'line') {
            const lambda = q / (chargeParamM || 1);
            E = (2 * k * lambda) / r;
            fieldFormula = `E = 2kλ/r = 2 × (9×10⁹ N⋅m²/C²) × (${lambda.toExponential(2)} C/m) / (${r.toFixed(3)} m)`;
          } else if (chargeType === 'cylinder') {
            const chargeRadius = chargeParamM;
            if (r >= chargeRadius) {
              const lambda = q / (h || 1);
              E = (2 * k * lambda) / r;
              fieldFormula = `E = 2kλ/r = 2 × (9×10⁹ N⋅m²/C²) × (${lambda.toExponential(2)} C/m) / (${r.toFixed(3)} m)`;
            } else {
              const rho = q / (Math.PI * chargeRadius * chargeRadius * (h || 1));
              E = (rho * r) / (2 * epsilon0);
              fieldFormula = `E = ρr/(2ε₀) = (${rho.toExponential(2)} C/m³) × (${r.toFixed(3)} m) / (2 × ${epsilon0.toExponential(2)} C²/N⋅m²)`;
            }
          } else if (chargeType === 'ring') {
            E = (k * qEnc) / (r * r);
            fieldFormula = `E = kQ_enc/r² = (9×10⁹ N⋅m²/C²) × (${qEnc.toExponential(2)} C) / (${r.toFixed(3)} m)²`;
          } else if (chargeType === 'plane') {
            const sigma = q / (chargeParamM * chargeParamM || 1);
            E = sigma / (2 * epsilon0);
            fieldFormula = `E = σ/(2ε₀) = (${sigma.toExponential(2)} C/m²) / (2 × ${epsilon0.toExponential(2)} C²/N⋅m²)`;
            // For plane with cylinder, flux through both ends
            if (shape === 'cylinder') {
              E = sigma / (2 * epsilon0); // Field on each side
            }
          }
          
          if (shape === 'sphere') {
            // For sphere: ∮ E · dA = E(4πr²) = q/ε₀
            const area = 4 * Math.PI * r * r;
            const fluxCalc = E * area;
            
            formulaHTML = `
              <div style="margin-bottom: 0.5rem;"><strong>∮ E · dA = Q_enc/ε₀</strong></div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Charge Distribution:</strong> ${chargeDescription}
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                For a <strong>spherical</strong> Gaussian surface:<br>
                E · (4πr²) = Q_enc/ε₀
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 1:</strong> Calculate electric field E<br>
                ${fieldFormula}<br>
                E = ${E.toExponential(2)} N/C
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 2:</strong> Calculate surface area A<br>
                A = 4πr² = 4π × (${r.toFixed(3)} m)²<br>
                A = ${area.toExponential(2)} m²
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 3:</strong> Calculate flux Φ = E · A<br>
                Φ = (${E.toExponential(2)} N/C) × (${area.toExponential(2)} m²)<br>
                Φ = ${fluxCalc.toExponential(2)} N⋅m²/C
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 4:</strong> Verify Gauss' Law<br>
                Q_enc/ε₀ = (${qEnc.toExponential(2)} C) / (${epsilon0.toExponential(2)} C²/N⋅m²)<br>
                Q_enc/ε₀ = ${flux.toExponential(2)} N⋅m²/C<br>
                <span style="color: ${isDark ? '#4ade80' : '#22c55e'}; font-weight: bold;">✓ Φ = Q_enc/ε₀</span>
              </div>
            `;
          } else if (shape === 'cylinder') {
            // For cylinder: ∮ E · dA = E(2πrh) = q/ε₀ (if charge is inside)
            const sideArea = 2 * Math.PI * r * h;
            let fluxSide = 0;
            let fluxTopBottom = 0;
            let fluxTotal = 0;
            
            if (chargeType === 'plane') {
              // For plane charge: flux only through top and bottom (E ⟂ side)
              const topArea = Math.PI * r * r;
              const sigma = q / (chargeParamM * chargeParamM || 1);
              const E_plane = sigma / (2 * epsilon0);
              fluxTopBottom = E_plane * topArea * 2; // Both top and bottom
              fluxTotal = fluxTopBottom;
            } else {
              // For other charges: flux through side only (E is radial)
              fluxSide = E * sideArea;
              fluxTotal = fluxSide;
            }
            
            formulaHTML = `
              <div style="margin-bottom: 0.5rem;"><strong>∮ E · dA = Q_enc/ε₀</strong></div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Charge Distribution:</strong> ${chargeDescription}
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                For a <strong>cylindrical</strong> Gaussian surface:<br>
                ${chargeType === 'plane' ? 'E · (2πr²) = Q_enc/ε₀ (flux through top/bottom only, side has E ⟂ dA)' : 'E · (2πrh) = Q_enc/ε₀ (flux through side only, top/bottom have E ⟂ dA)'}
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 1:</strong> Calculate electric field E${chargeType === 'plane' ? ' (perpendicular to plane)' : ' (radial)'}<br>
                ${fieldFormula}<br>
                E = ${chargeType === 'plane' ? (q / (chargeParamM * chargeParamM || 1) / (2 * epsilon0)).toExponential(2) : E.toExponential(2)} N/C
              </div>
              ${chargeType === 'plane' ? `
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 2:</strong> Calculate top/bottom surface area A<br>
                A = 2 × πr² = 2 × π × (${r.toFixed(3)} m)²<br>
                A = ${(2 * Math.PI * r * r).toExponential(2)} m²
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 3:</strong> Calculate flux Φ = E · A<br>
                Φ = (${(q / (chargeParamM * chargeParamM || 1) / (2 * epsilon0)).toExponential(2)} N/C) × (${(2 * Math.PI * r * r).toExponential(2)} m²)<br>
                Φ = ${fluxTotal.toExponential(2)} N⋅m²/C<br>
                <small>(Flux through side = 0, since E ⟂ dA)</small>
              </div>
              ` : `
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 2:</strong> Calculate side surface area A_side<br>
                A_side = 2πrh = 2π × (${r.toFixed(3)} m) × (${h.toFixed(3)} m)<br>
                A_side = ${sideArea.toExponential(2)} m²
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 3:</strong> Calculate flux Φ = E · A_side<br>
                Φ = (${E.toExponential(2)} N/C) × (${sideArea.toExponential(2)} m²)<br>
                Φ = ${fluxTotal.toExponential(2)} N⋅m²/C<br>
                <small>(Flux through top/bottom = 0, since E ⟂ dA)</small>
              </div>
              `}
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step ${chargeType === 'plane' ? '4' : '4'}:</strong> Verify Gauss' Law<br>
                Q_enc/ε₀ = (${qEnc.toExponential(2)} C) / (${epsilon0.toExponential(2)} C²/N⋅m²)<br>
                Q_enc/ε₀ = ${flux.toExponential(2)} N⋅m²/C<br>
                <span style="color: ${isDark ? '#4ade80' : '#22c55e'}; font-weight: bold;">✓ Φ = Q_enc/ε₀</span>
              </div>
            `;
          } else if (shape === 'ring') {
            // For ring (torus): Surface area = 4π²Rr where R is major radius, r is minor radius
            // For simplicity, we use the same radius for both (R = r)
            // Torus surface area: A = 4π²Rr, where R = r (major radius = minor radius)
            const ringArea = 4 * Math.PI * Math.PI * r * r;
            const fluxRing = E * ringArea;
            
            formulaHTML = `
              <div style="margin-bottom: 0.5rem;"><strong>∮ E · dA = Q_enc/ε₀</strong></div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Charge Distribution:</strong> ${chargeDescription}
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                For a <strong>ring</strong> (torus) Gaussian surface:<br>
                E · A_ring = Q_enc/ε₀
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 1:</strong> Calculate electric field E<br>
                ${fieldFormula}<br>
                E = ${E.toExponential(2)} N/C
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 2:</strong> Calculate ring (torus) surface area A<br>
                A = 4π²Rr = 4π² × (${r.toFixed(3)} m) × (${r.toFixed(3)} m)<br>
                A = ${ringArea.toExponential(2)} m²<br>
                <small>(For torus: R = major radius, r = minor radius, here R = r)</small>
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 3:</strong> Calculate flux Φ = E · A<br>
                Φ = (${E.toExponential(2)} N/C) × (${ringArea.toExponential(2)} m²)<br>
                Φ = ${fluxRing.toExponential(2)} N⋅m²/C
              </div>
              <div style="margin-left: 1rem; margin-bottom: 0.5rem;">
                <strong>Step 4:</strong> Verify Gauss' Law<br>
                Q_enc/ε₀ = (${qEnc.toExponential(2)} C) / (${epsilon0.toExponential(2)} C²/N⋅m²)<br>
                Q_enc/ε₀ = ${flux.toExponential(2)} N⋅m²/C<br>
                <span style="color: ${isDark ? '#4ade80' : '#22c55e'}; font-weight: bold;">✓ Φ = Q_enc/ε₀</span>
              </div>
            `;
          }
          
          document.getElementById('gauss-formula-content').innerHTML = formulaHTML;
        }
        
        function drawGauss() {
          ctx.fillStyle = isDark ? '#1a1a1a' : '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          const chargeType = document.getElementById('gauss-charge-type').value;
          const charge = parseFloat(document.getElementById('gauss-charge').value);
          const chargeParam = document.getElementById('gauss-charge-param') ? parseFloat(document.getElementById('gauss-charge-param').value) : 0;
          const shape = document.getElementById('gauss-shape').value;
          const radius = parseFloat(document.getElementById('gauss-radius').value);
          const height = document.getElementById('gauss-height') ? parseFloat(document.getElementById('gauss-height').value) : 200;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          
          // Draw charge distribution first (behind Gaussian surface)
          ctx.fillStyle = charge > 0 ? (isDark ? 'rgba(252, 165, 165, 0.4)' : 'rgba(229, 57, 53, 0.4)') : (isDark ? 'rgba(147, 197, 253, 0.4)' : 'rgba(25, 118, 210, 0.4)');
          ctx.strokeStyle = charge > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
          ctx.lineWidth = 2;
          
          if (chargeType === 'point') {
            const chargeRadius = Math.abs(charge) * 3 + 8;
            ctx.beginPath();
            ctx.arc(centerX, centerY, chargeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(charge > 0 ? '+' : '-', centerX, centerY + 5);
          } else if (chargeType === 'line') {
            // Draw vertical line of charge
            const lineLength = chargeParam || height;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - lineLength / 2);
            ctx.lineTo(centerX, centerY + lineLength / 2);
            ctx.lineWidth = 4;
            ctx.stroke();
            // Draw charge symbols along the line
            ctx.fillStyle = charge > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            for (let i = -2; i <= 2; i++) {
              const y = centerY + (i * lineLength / 5);
              ctx.beginPath();
              ctx.arc(centerX, y, 6, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (chargeType === 'cylinder') {
            // Draw cylinder of charge
            const chargeRadius = chargeParam || 50;
            const topY = centerY - height / 2;
            const bottomY = centerY + height / 2;
            // Draw filled cylinder
            ctx.fillRect(centerX - chargeRadius, topY, chargeRadius * 2, height);
            ctx.strokeRect(centerX - chargeRadius, topY, chargeRadius * 2, height);
            // Draw top and bottom circles
            ctx.beginPath();
            ctx.ellipse(centerX, topY, chargeRadius, chargeRadius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(centerX, bottomY, chargeRadius, chargeRadius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          } else if (chargeType === 'ring') {
            // Draw ring of charge
            const ringRadius = chargeParam || 100;
            ctx.beginPath();
            ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
            ctx.lineWidth = 8;
            ctx.stroke();
            // Draw charge symbols around the ring
            ctx.fillStyle = charge > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            for (let i = 0; i < 8; i++) {
              const angle = (i * Math.PI * 2) / 8;
              const x = centerX + Math.cos(angle) * ringRadius;
              const y = centerY + Math.sin(angle) * ringRadius;
              ctx.beginPath();
              ctx.arc(x, y, 6, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (chargeType === 'plane') {
            // Draw plane of charge (horizontal line)
            const planeWidth = chargeParam || 400;
            ctx.beginPath();
            ctx.moveTo(centerX - planeWidth / 2, centerY);
            ctx.lineTo(centerX + planeWidth / 2, centerY);
            ctx.lineWidth = 6;
            ctx.stroke();
            // Draw charge symbols along the plane
            ctx.fillStyle = charge > 0 ? (isDark ? '#fca5a5' : '#e53935') : (isDark ? '#93c5fd' : '#1976d2');
            for (let i = -4; i <= 4; i++) {
              const x = centerX + (i * planeWidth / 9);
              ctx.beginPath();
              ctx.arc(x, centerY, 6, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          // Draw Gaussian surface
          ctx.strokeStyle = isDark ? 'rgba(129, 140, 248, 0.8)' : 'rgba(26, 35, 126, 0.8)';
          ctx.lineWidth = 3;
          ctx.setLineDash([10, 5]);
          
          if (shape === 'sphere') {
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
          } else if (shape === 'cylinder') {
            // Draw cylinder (side view as rectangle with ellipses on top/bottom)
            const topY = centerY - height / 2;
            const bottomY = centerY + height / 2;
            
            // Draw side lines
            ctx.beginPath();
            ctx.moveTo(centerX - radius, topY);
            ctx.lineTo(centerX - radius, bottomY);
            ctx.moveTo(centerX + radius, topY);
            ctx.lineTo(centerX + radius, bottomY);
            ctx.stroke();
            
            // Draw top ellipse
            ctx.beginPath();
            ctx.ellipse(centerX, topY, radius, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw bottom ellipse
            ctx.beginPath();
            ctx.ellipse(centerX, bottomY, radius, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.stroke();
          } else if (shape === 'ring') {
            // Draw ring (torus) - side view as two circles
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw inner circle to show it's a ring
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw connecting lines to show it's a torus
            ctx.beginPath();
            ctx.moveTo(centerX - radius, centerY);
            ctx.lineTo(centerX - radius * 0.6, centerY);
            ctx.moveTo(centerX + radius, centerY);
            ctx.lineTo(centerX + radius * 0.6, centerY);
            ctx.stroke();
          }
          
          ctx.setLineDash([]);
          
          // Update formula display
          updateFormulaDisplay();
        }
        
        // Charge type selector handler
        document.getElementById('gauss-charge-type').addEventListener('change', (e) => {
          const chargeType = e.target.value;
          const chargeLabel = document.getElementById('gauss-charge-label');
          const chargeUnit = document.getElementById('gauss-charge-unit');
          const chargeParamGroup = document.getElementById('gauss-charge-param-group');
          const chargeParamLabel = document.getElementById('gauss-charge-param-label');
          const chargeParamUnit = document.getElementById('gauss-charge-param-unit');
          const chargeInput = document.getElementById('gauss-charge');
          
          if (chargeType === 'point') {
            chargeLabel.textContent = 'Point Charge (q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'none';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          } else if (chargeType === 'line') {
            chargeLabel.textContent = 'Total Charge (Q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'flex';
            chargeParamLabel.textContent = 'Line Length (L):';
            chargeParamUnit.textContent = 'px';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          } else if (chargeType === 'cylinder') {
            chargeLabel.textContent = 'Total Charge (Q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'flex';
            chargeParamLabel.textContent = 'Cylinder Radius (R):';
            chargeParamUnit.textContent = 'px';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          } else if (chargeType === 'ring') {
            chargeLabel.textContent = 'Total Charge (Q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'flex';
            chargeParamLabel.textContent = 'Ring Radius (R):';
            chargeParamUnit.textContent = 'px';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          } else if (chargeType === 'plane') {
            chargeLabel.textContent = 'Total Charge (Q):';
            chargeUnit.textContent = '× 10⁻⁹ C';
            chargeParamGroup.style.display = 'flex';
            chargeParamLabel.textContent = 'Plane Width (W):';
            chargeParamUnit.textContent = 'px';
            chargeInput.min = '-10';
            chargeInput.max = '10';
          }
          drawGauss();
        });
        
        // Shape selector handler
        document.getElementById('gauss-shape').addEventListener('change', (e) => {
          const shape = e.target.value;
          const heightGroup = document.getElementById('gauss-height-group');
          const sizeLabel = document.getElementById('gauss-size-label');
          
          if (shape === 'cylinder') {
            heightGroup.style.display = 'flex';
            sizeLabel.textContent = 'Radius (r):';
          } else if (shape === 'ring') {
            heightGroup.style.display = 'none';
            sizeLabel.textContent = 'Radius (r):';
          } else {
            heightGroup.style.display = 'none';
            sizeLabel.textContent = 'Radius (r):';
          }
          drawGauss();
        });
        
        // Toggle calculation display button
        const toggleButton = document.getElementById('gauss-toggle-calculation');
        const formulaDisplay = document.getElementById('gauss-formula-display');
        toggleButton.addEventListener('click', () => {
          const isVisible = formulaDisplay.style.display !== 'none';
          if (isVisible) {
            formulaDisplay.style.display = 'none';
            toggleButton.textContent = 'Show Calculation';
          } else {
            formulaDisplay.style.display = 'block';
            toggleButton.textContent = 'Hide Calculation';
            // Update formula display when showing
            updateFormulaDisplay();
          }
        });
        
        drawGauss();
        document.getElementById('gauss-charge').addEventListener('input', (e) => {
          document.getElementById('gauss-charge-value').textContent = e.target.value;
          drawGauss();
        });
        const chargeParamInput = document.getElementById('gauss-charge-param');
        if (chargeParamInput) {
          chargeParamInput.addEventListener('input', (e) => {
            document.getElementById('gauss-charge-param-value').textContent = e.target.value;
            drawGauss();
          });
        }
        document.getElementById('gauss-radius').addEventListener('input', (e) => {
          document.getElementById('gauss-radius-value').textContent = e.target.value;
          drawGauss();
        });
        const heightInput = document.getElementById('gauss-height');
        if (heightInput) {
          heightInput.addEventListener('input', (e) => {
            document.getElementById('gauss-height-value').textContent = e.target.value;
            drawGauss();
          });
        }
      }
    });
  </script>
</body>
</html>

